### 函数的特性

1. 从用户使用角度看，函数分为**库函数**和**用户自定义函数**
2. 从函数的形式看，函数分**有参函数**和**无参函数**
3. 程序结构图

```c
               程序
      |          |              |
   源程序文件a  源程序文件b   源程序文件c
 |    |      |
函数a 函数b 函数c
```

4. 函数不能嵌套定义，函数可以互相调用，但是 main 函数不能互相调用。

### 函数定义

```c
int Column; // 定义全局变量
static int Column // 静态全局变量，只允许当前文件引用，不允许外部文件引用;
int max(int x, int y) {
  if(x > y) return x;
  else return y;
}

int main()
{
  int max(int x, int y); // 函数声明形式1
  int max(int s, int b) // 函数声明形式2 改变参数名称
  int max(int, int) // 函数声明形式2 默认不适用参数
  printf("%d\n", max(3, 4));
}

// 函数定义的一般形式
/*
类型名 函数名()
{
   函数体
}
*/
// 调用函数
/*
 函数名()
 函数名(实参表列)
*/
```

### 函数调用过程(以上面函数定位为例)

1. 在定义函数中指定的形参，在未出现函数调用时，他们并不占用内存中的存储单元，在发生函数调用时，函数 max 中的形参被分配内存单元
2. 将实参对应的值传递给形参
3. 在执行 max 函数期间，由于形参已经有值，就可以进行有关的运算
4. 通过 return 语句将函数值带回到主调函数
5. 调用结束，形参单元被释放
6. **调用函数的方式**：
   - 函数语句：pinrt_star()
   - 函数表达式：c = 2 \* max(a,b);
   - 函数参数:printf("%d", max(a,b));

### 函数调用(普通调用)

重点：**函数形参是按值传递的(传整个数组除外，数组是按地址传递)，就算函数内改变原来参数的值，原来参数的值也不受影响（包括传数组某一项）**，

1. 函数定义：**指对函数功能的确立**，它是一个完整的，独立的函数单位。
2. 函数声明的作用：把函数名，函数参数的个数和参数类型等信息通知编译系统，编译系统能据此识别函数并检查函数调用是否合法，即**对函数调用的合法性进行检查**。**C 语言对形参数组的大小不做检查，因此形参数组可以不指定大小**
3. 函数声明的说明: 如果被调用函数的定义出现在 main 函数之前，那可以不加函数声明
4. 函数原型：就是**函数声明，函数声明也叫函数原型**

```js
/**
函数调用过程范例：
void main() {
   int max(int, int); // 函数声明简写，不写参数名，只写参数类型
   int max(int u, int v) // 函数生命简写，参数名不用x,y，直接使用u,v
}
int max(int x, int y) { // 形参x,y不占内存中的存储单元
   if(x>y) {
      return x;
   } else {
      return y;
   }
}
1. 在定义函数中指定的形参，在未出现函数调用时，他们并不占内存中的存储单元，直到函数发生调用时，函数max中的形参才被分配内存单元
2. 将实参对应的值传递给形参
3. 在执行max期间，由于形参已经有值，就可以进行有关的运算
4. 通过return语句将函数值带回到主调函数
5. 调用结束后，形参单元被释放
 */
```

### 函数调用(传整个数组情况)

1. 用变量名或数组元素名作函数参数时，传递的是变量的值，用数组名作函数参数时，传递的是数组首元素的地址。
2. 由于数组名代表数组首元素的地址，因此只是将数组的首元素的地址传输给对应形参
3. 函数调用时虚实结合的方式：**1. 值传递 2. 地址传递**

### 函数的嵌套调用和递归调用

**嵌套调用**：在调用一个函数过程中调用另外一个函数，称为函数的嵌套调用。
**递归调用**：在调用函数过程中直接或间接地调用该函数本身，称为函数的递归调用。

### 多维数组作为函数实参

1. 在被调用函数中对形参数组进行声明时，可以指定每一维的大小，也可以省略第一维的大小说明, 但不能只指定第一行
   ```c
   // 合法
   float fn(float arr[5][5])
   float fn(float arr[][5])
   // 不合法
   float fn(float arr[][])
   float fn(float arr[4][])
   ```

### 变量的作用域和生存期

1. 变量的作用域：指**变量的有效的范围**，分为局部变量和全局变量
2. 变量的生存期：指**变量存在的时间**
3. 内部变量/局部变量：**在函数或复合语句中定义的变量，只在本函数或复合语句内范围有效**。使用时才分配存储单元，不占用空间。也叫**动态存储方式**,函数内的变量，函数调用完释放回收空间
   - 主函数内的变量也是局部变量
   - 不同函数中可以使用相同名字的变量，他们互不干扰
   - 形参也是局部变量
   - 在函数内部可以在复合语句中定义变量，这些变量只在复合语句中有效
   - 复合语句：**将两条或以上的语句用{}括起来的语句**
4. 外部变量/全局变量：在函数外定义的变量，提前分配存储单元，占用空间。**全局变量的有效范围从定义变量的位置开始到本源程序文件结束，在此范围内可以为本程序文件中的所有函数所共用**，也叫**静态存储方式**，在函数外定义的变量，程序运行过程中都存在。
5. **C 语言程序组成**：一个程序可以包含**一个或若干个源程序文件，而一个源程序文件可以包含一个或若干个函数**。全局变量普通情况下只在一个文件内生效
6. 变量的可见性：一个变量在其作用域内可以被引用，则称此变量在作用域内"可见"
7. 变量的生存期：如果一个变量值在某一时刻是存在的，则认为这一时刻属于该变量的“生存期”,或称该变量在此时刻“存在”

```c
// 全局变量定义
#include <stdio.h>
int Row, Column;

void main() {

}
```

### 变量的存储类别

1. 每一个变量和函数都有两个属性：**数据类型**和**数据存储类别**，定义变量时除了需要定义数据类型外，还可以指定定义其存储类别

### 变量的存储类别分类

1. auto: 声明自动变量，比如函数形参和在函数中定义的变量，在函数调用结束时就自动释放这些存储空间，所以这类变量被称为**自动变量**，auto 关键字可以省略。它属于动态存储类别

```c
auto int b,c = 3;
```

2. static：声明静态变量，函数中的静态局部变量在调用结束后不消失而保留原值。该变量在整个程序运行期间都不释放空间(缩略图 239)，静态局部变量不赋初值时，会自动赋初值 0(对数值型变量)或空字符(对字符变量)，如果希望外部变量只限于被本文件引用，只能用于本文件的外部变量，称为**静态外部变量**
   - static 对局部变量：使变量由动态存储改变为静态存储方式。
   - static 对全局变量：使全局变量局部化，只能被本文件引用

```c
static int f = 1; // 只初始化一次，在程序运行期间都不释放空间，不能被外部其他文件所引用
```

3. register：寄存器变量。一些频繁使用的变量(比如循环 10000 次)，每次循环都要引用局部变量，这种频繁操作的变量每次存储都会花费很多时间，为提高效率直接放 cpu 的寄存器中，增加存取速度

```c
register int f;
```

4. extern：**声明外部变量的作用范围**，
   - 作用 1：**在一个文件内扩展外部变量的作用域**， 因为全局变量的作用域只在于从定义点到文件结束(全局变量不一定写在最头部)，这样会导致上面的函数引用不到全局变量(缩略图 241)
   - 作用 2：**将外部变量的作用域扩展到其他文件**

```c
// global.c
int globalVar = 10;

// main.c
#include <stdio.h>

extern int globalVar;  // extern关键字声明全局变量，引用global.c内的变量

int main() {
  extern int juan; // 拓展全局变量的作用域
  printf("Global variable: %d\n", globalVar);
  printf("%d\n", juan); // 2
  return 0;
}

int juan = 2; // 当前变量有效范围从该位置开始到本源程序文件
```

### 内部函数和外部函数

1. 内部函数：又称**静态函数**，只能被本文件中的其他函数所调用，不同文件中有同名的内部函数互不干扰，比如 static int fun(int a, int b);
2. 外部函数：定义时在函数处加 extern 的函数，可以被其他文件调用，**extern 可省略**，比如 extern int fun(int a, int b);

```c
// functions.c
#include <stdio.h>

void printMessage()
{
    printf("Hello, extern!\n");
}

// main.c

int main() {
  // 引用外部函数
  extern void printMessage();
}
```

### C 文件的有关概念

0. 文件类型：**数据文件**，**程序文件**
1. 程序文件：包括源文件(.c)，目标文件(.obj)，可执行文件(.exe)，这种文件是用来存放程序的，以便实现程序的功能。
2. 数据文件：**供程序运行时读写的数据**。
3. 文件：**存储在外部介质上数据的集合**，如：磁盘，U 盘等。
4. 输入输出流：**表示了信息从源到目的端的流动**。输入操作时，数据从文件流向计算机内存，输出操作时，数据从计算机流向文件(如打印机，磁盘)
5. 流式文件：以字节为单位的文件，由一连串字节组成，中间没有分隔符，对文件的存取是以字节为单位的文件。
6. 数据文件的分类：**ASCII 文件**，也称作文本文件和**二进制文件**
7. 文件标识：**文件路径，文件主干，文件后缀**
   - ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311271554481.png)
8. 文件缓冲系统：系统自动在内存区为程序中每一个正在使用的文件开辟一个**文件缓冲区**。
9. 文件缓冲区：系统在读写程序时在内存中开辟的数据源与数据目标中间的一个用于保存完整数据内容的缓冲区域。
10. 文件类型指针：**在打开文件时，会在内存建立一个文件信息区，存放文件的有关特征和当前状态。这个信息的数据组织成结构体类型，系统将其命名了 FILE 类型。文件类型指针就是指向文件结构体类型变量的指针，即指向 FILE 文件类型的指针**
11. 通过文件指针访问文件的好处：可以随机访问文件，有效表示数据结构，动态分配内存，方便使用字符串，有效使用数组。
12. 文件信息区：用来存放文件的有关信息(如文件名，文件状态，文件当前位置等)，系统将其命名为 FILE 类型
13. 文件的打开和关闭：所谓的“打开”是指为文件建立相应的信息区和文件缓冲区。“关闭”是指撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件。

### 文件缓冲区

1. 定义：C 语言采用"**缓冲文件系统**"处理文件，是指系统自动在内存区为程序中每一个正在使用的文件开辟一个**文件缓冲区**，从内存中向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才送到磁盘，如果从磁盘向内存中读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量)，缓冲区大小由各个具体的 C 编译系统确定。

### 文件指针类型

1. 定义：缓冲文件系统中，关键的是文件类型指针，简称**文件指针**，每个被使用的文件都在内存中开辟一个相应的**文件信息区**，用来存放文件的有关信息(如文件名，文件状态，文件当前位置等)。这些信息是保存在一个结构体变量中的，该结构体变量由系统声明存放在头文件"stdio.h"中，叫 FILE，在程序中可以直接使用 FILE 类型定义名词。

### 文件的打开和关闭

1. fopen(文件名，使用文件方式:r/w/a/rb/wb/ab/r+/w+/a+/rb+/wb+/ab+) 失败返回 NULL，成功返回文件首地址。**使用 fopen 时，若以"读"的模式打开，文件必须存在；若以"写"的模式(只要含有 w)打开时，文件可以不存在，会自动创建**
2. fclose(文件指针) 成功返回 0，失败返回 EOF(-1)，**关闭就是撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，使文件指针变量与文件脱钩，此后不能通过该指针对原来与其相联系的文件进行读写，**，**如前所述,在向文件写数据时,是先将数据输出到缓冲区,待缓冲区充满后才正式输出给文件。如果当数据未充满缓冲区而程序结束运行,就会将缓冲区中的数据丢失。用 fclose 函数关闭文件,可以避免这个问题,它先把缓冲区中的数据输出到磁盘文件,然后才释放文件指针变量。**

```c
FILE *fp;
fp = fopen("a1", "r");
fclose(fp);

```

### 文件的顺序读写

#### 向文件读取字符

1. fgetc(fp)： 从 fp 指向的文件读入一个字符，成功返回所读字符，失败返回 EOF(-1)
2. fputc(ch, fp)：把字符 ch 写到文件指针变量 fp 所指向的文件中，成功返回输出字符，失败返回 EOF(-1)，**写入时会清空文件原有的文本**
3. feof(in)：检测文件尾标志 EOF 是否已被读过。被读过表示文件有效字符已全部读完，返回 非 0，否则返回 0
4. 文件读取为什么是按顺序的：访问磁盘文件是逐个字节进行的，为了知道当前访问到第几自己，系统用**文件读写位置标记**来表示**当前所访问的位置**，每访问完一个字节后，当前位置标记就指向下一字节。为了知道对文件的访问是否完成，在一个文件的有效字符的后面一字节中，系统自动设置了一个**文件尾标志**，用 EOF 表示,在 stdio 头文件 EOF 被定义为-1，当读完全部有效字符后，读写位置标记就指向 EOF，再执行一次读操作就读入 EOF,这个时候表示有效字符已经读完。

### 结构体 struct

1. 定义：由用户自己建立由不同类型数据组成的组合型的数据结构，被称为**结构体**。在其他高级语言中把这种形式的数据结构称为“**记录**”
2. 特点：**结构体变量所占内存长度是各成员占的内存长度之和**，每个成员分别占有自己的内存单元
3. **结构体规则：**
   - 结构体变量中的成员的引用方式为：结构体变量名.成员名
   - 嵌套的结构体，则用类似于 student1.birthday.month
   - 对结构体的变量的成员可以像普通变量一样进行各种运算
   - 同类型的结构体变量可以相互赋值，比如下面例子可以直接 student1 = student2;
   - 可以引用结构体变量成员或结构体变量的地址,
   ```c
   scanf("%d", &student2.num);
   scanf("%o", &student2);
   ```
4. **结构体指针：指向结构体数据的指针,一个结构体变量的起始地址就是这个结构体变量的指针。**
5. 定义结构体的方式：**只能对结构体变量赋值，存取或运算，而不能对一个类型赋值，存取或运算。在编译时对类型是不分配空间的，只对变量分配空间**

```c
// 定义
struct 结构体名 {  // struct student合起来即为结构体类型名
  成员表列
} 变量名表列
// 例子1：先声明结构体类型，再定义该类型的变量
struct student {
  int num;
  char name[20];
  char sex;
  char addr[20];
}
struct student student1, student2 = { 10101, "shuhongxie", 'M', "guangzhou" };;
// struct student => 结构体类型名  student1,student2 => 结构体变量名
// 例子2：在声明类型的同时定义变量
struct student {
  int num;
  char name[20];
  char sex;
  char addr[20];
} student1, student2 = { 10101, "shuhongxie", 'M', "guangzhou" }; // 直接声明和定义
// 例子3：不指定类型名而直接定义结构体类型变量
struct  {
  int num;
  char name[20];
  char sex;
  char addr[20];
} student1, student2 = { 10101, "shuhongxie", 'M', "guangzhou" }; // 直接声明和定义
```

### 结构体数组

```c
// 定义1
struct 结构体名 {
  成员表列
} 数组名[数组长度];
// 定义2
结构体类型 数组名[数组长度];
struct person leader[3]; // 未初始化
struct person leader[3] = { "Li", 0, "Zhang", 0, "Func", 0 }; // 已初始化

// 示例
struct person {
  char name[20];
  int count;
} leader[3] = {"Li",0,"Zhang",0,"Fun",0};
```

### 结构体指针

1. 定义：**结构体指针就是指向结构体数据的指针，一个结构体变量的起始地址就是这个结构体变量的指针**
2. 指向运算符：(\*p).num 可以变成 p->num;

```c
struct student *pt;

struct student {
  int num;
  float score;
  struct student *next;
} std;
pt = &std;
/*
调用函数体的值，可以写成以下三种形式
1. std.num
2. (*p).num
3. p->num
*/
```

### 用结构体变量和结构体变量的指针做函数参数

1. 结构体变量或结构体成员作为实参进行函数调用时，采取的是“值传递”，等于将结构体变量或结构体成员变量的值传给形参。但如果结构体成员是数组的话除外
2. 结构体指针变量作为实参进行函数调用时，传输的是结构体的地址

### 结构体和动态链表

1. 使用 malloc 方法**动态分配内存**

### 共用体类型

1. 特点：**结构体变量所占内存长度是各成员占的内存长度之和，共用体变量所占内存长度等于最长的成员的长度**
2. 由于共同体变量中的各个成员共用同一块存储空间，因此，在任一时刻，只能存放一个成员的值。
3. 共用体变量中起作用的成员值是最后一次被赋值的成员值。即再次赋值会覆盖之前的值。
4. 共用体变量的地址和它成员的地址都是同一地址
5. **可以对结构体进行赋值，但不能对共用体变量赋值也不能企图引用共用体变量来得到成员的值。**

```c
union data {
  short int i;
  char ch;
  float f;
} a, b,c;
// 共用体不能用变量进行初始化 比如  a = { 2, 'Z', '3.1' }
// 只能这样
a.i = 20;
a.ch = 'X';
a.f = 3.14142;
// 不能引用共用体变量，只能引用共用体变量中的成员 比如a.i
```

### 枚举类型(不重要)

```c
// 定义
enum weekday { sun, mon, tue, wed, thu, fri, sat }; // sun,mon,tue 被称为枚举元素或枚举常量，他们是用户定义的标识符
// 使用
// workday,week_end 被称为枚举变量，他们的值只能是sun到sat之一
enum weekday workday,week_end; // 枚举变量
workday = mon;
week_end = sun
// 也可以直接定义枚举变量
enum weekday { sun, mon, tue, wed, thu,fri,sat } workday,week_end;
```

### 共用体类型

1. 特点：**结构体变量所占内存长度是各成员占的内存长度之和，共用体变量所占内存长度等于最长的成员的长度**
