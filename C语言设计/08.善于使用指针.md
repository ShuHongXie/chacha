### 指针及相关概念

1. C 语言定义变量时对该变量分配内存单元，每个内存单元都会有一个编号，这就内存单元的地址，**地址指向该变量单元，将地址形象化地称为"指针"**，C 语言的地址都是带类型的地址，只有纯地址是无法对内存单元进行访问的
2. 指针：一个变量的地址
3. 指针变量：有一个变量专门用来存在另一变量的地址，即为**指针变量**，指针变量就是地址变量，指针变量的值是地址
   - 指针变量名前面的\*表示该变量的类型为指针型变量。
   - 定义指针变量必须指定基类型，因为不同类型的所占字节不同
   - 赋给指针变量的是变量地址而不能是任意类型的数据，而且只能说与指针变量的基类型相同类型的变量的地址。
   - 指针变量中只能存放地址

```c
// 定义指针变量
int a =100;
// *p1 代表p1所指向的变量，也就是变量a
int *p1 = &a,; // 可以初始化也可以不初始化
printf("%d", *p1);
/*
※※※※※※※※※※
上面 int *p1表示定义p1为整型指针变量，
p1 =  &a; 表示把a的地址赋予p1，这个时候p1就指向了a；
后面*p1代表p1所指向的对象，也就是a

即
*p => 变量a
p => 变量a的地址
※※※※※※※※※※
*/
```

### 指针变量赋值过程中发生了什么(以下面代码为例子)

```c
int a;
int *p=&a;
```

1. 定义一个指向整型类数据的指针变量 p
2. **把 p 整型变量地址&a 赋值给 p，使得 p 指向 a，其中&a 包含 2 个信息：纯地址和 a 的类型。赋值时会先检查&a 和 p 的类型是否相同，不相同不能赋值**

### 指针变量作为函数参数

1. 指针变量作为实参，是按值传递的, 数组除外
2. **不能通过调用函数来改变实参指针变量的值，但可以改变实参指针变量所指变量的值**

```js
// 由上面给出的解释

// 1. 不能在所调用的函数里面直接更换指针变量的地址，如 int * a; a= b;
// 2. 能在函数里面直接使用 int a; a = *p，*p = 123; 即直接改变了指针变量所指变量的值
```

### 通过指针引用数组

```c
int a[10];
int *p;
p = &a[0]; // 或者p=a
```

### 以变量名和数组名作为函数参数的比较

|           实参类型           |  变量名  |         数组名         |
| :--------------------------: | :------: | :--------------------: |
|        要求形参的类型        |  变量名  |    数组名或指针变量    |
|          传递的信息          | 变量的值 |  实参数组首元素的地址  |
| 通过函数调用能否改变实参的值 |   不能   | 能改变实参数组元素的值 |

### 通过指针引用字符串

1. 使用字符指针变量和字符数组的区别：
   - 字符指针变量中存放的是地址，而不是将字符串放到字符指针变量中
   - 对字符数组的赋值，有些可以赋值，有些则不行, 即**数组可以在定义时整体赋初值，但不能再赋值语句中整体赋值，指针变量除外**
   ```c
   // 不合法
   char str[14];
   str = "I love china";
   // 合法
   char *a;
   a =  "I love china";
   ```
   - **数字符数组中个元素的值可以改变，但字符指针变量指向的字符串常来那个中的内容不可以被替代**数
   ```c
   char a[] = "House";
   char *b = " House";
   a[2] = r; // 合法
   b[2] = r; // 非法：字符串常量不能改变
   ```

```c
char *string = "i love china";

```

### 易错地方

1. 输入两个值，按从大到小排列

```c
// 运行下面代码 输入5,9 打印出来的也是5,9
// C语言中实参变量和形参变量的数据传递是单项的值传递，用指针变量也要遵守这一情况
int main()
{
  void swap(int *p1, int *p2);
  int *z1, *z2, a, b;
  scanf("%d,%d", &a, &b);
  z1 = &a;
  z2 = &b;
  if (a < b)
  {
    swap(z1, z2);
  }
  printf("max=%d,min=%d\n", a, b);
  return 0;
}

void swap(int *p1, int *p2)
{
  int *p;
  p = p1;
  p1 = p2;
  p2 = p;
}
```

## 提高部分

1. 多维数组的指针

```c
int a[3][4] = {{1,3,5,7}, {9,11,13,15}, {17,19,21,23}};
/**
 上面a是数组名，有3行，同时也代表着二维数组首元素的地址，首元素是由4个整型元素所组成的一维数组，因此a代表的是首行的的首地址
*/
int (*p)[4]; // 定义一个指向有4个元素的一维数组，如果有p=a+1; 则p指向a[2]的地址；

```

2. **指向函数的指针： 数据类型 (\*指针变量名)(函数参数表列);**

```c
int (*p)(int, int)
```

3. **返回指针值的函数：类型名 \*函数名(参数表列);**

```c
int *a(int x,int y);
```

4. 指针数组：

```c
int *p[4];
```

5. 多重指针：即**指向指针的指针**

```c
char **p;
```

6. 总结：**定义指针型变量的时候，只要是\*号包含在括号内的，那么就属于指向 xx 的指针变量**

| 定义         | 含义                                                      |
| ------------ | --------------------------------------------------------- |
| int i        | 定义整型变量 i                                            |
| int \*p      | p 为指向整型数据的指针变量                                |
| int a[n]     | 定义整型数组，它有 n 个元素                               |
| int \*p[n]   | 定义指针数组，它由 n 个指向整型数据的指针元素组成         |
| int (\*p)[n] | p 为指向含 n 个元素的一维数组的指针变量                   |
| int f()      | f 为返回整型的函数                                        |
| int \*p()    | p 为返回一个指针的函数，该指针指向整型数据                |
| int (\*p)()  | p 为指向函数的指针，该函数返回一个整型值                  |
| int \*\*p    | p 是一个函数指针，它指向一个指向整型数据的变量            |
| void \*p     | p 是一个指针变量，基类型为 void(空类型), 不指向具体的数据 |

### 指针运算小结

1. 指针变量的空值 NULL：指针变量可以有空值，即该指针变量不指向任何变量，NULL 是一个符号常量，在 stdio.h 头文件里面已经对 NULL 进行了定义,**任何指针变量或地址都可以与 NULL 做相等或不相等的比较**

```c
if(p == NULL)...
```

2. 指针运算小结
   - 例如：p++,p--,p+i,p-i 等均是指针变量加(减)一个整数。将该指针变量的值(地址)h 和它指向的变量所占用的内存单元字节数相(减)
   - 两个指针变量可以相减，相减之差是两个指针之间的元素个数
   - 两个指针变量可以比较，指向前面元素的指针变量小于后面元素的指针变量
