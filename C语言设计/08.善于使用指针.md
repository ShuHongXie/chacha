### 指针及相关概念

1. C 语言定义变量时对该变量分配内存单元，每个内存单元都会有一个编号，这就内存单元的地址，**地址指向该变量单元，将地址形象化地称为"指针"**，C 语言的地址都是带类型的地址，只有纯地址是无法对内存单元进行访问的
2. **直接访问**：如 int a=3; printf("%d", a); 这种形式
3. **间接访问**：如 int a=3, \*p = &a; printf("%d", a); 这种形式
4. 指针：一个变量的地址
5. **如果一个指针变量中存放了一个整型变量的地址，则称这个变量是指向整型变量的指针变量**
6. 指针变量：有一个变量专门用来存储另一变量的地址，即为**指针变量**，指针变量就是地址变量，指针变量的值是地址
   - 指针变量名前面的\*表示该变量的类型为指针变量。
   - 定义指针变量必须指定基类型，因为不同类型的所占字节不同
   - 赋给指针变量的是变量地址而不能是任意类型的数据，而且只能是与指针变量的基类型相同类型的变量的地址。
   - 指针变量中只能存放地址，不能\*p1=100;系统无法分辨它是否是地址
   - 将指针变量赋予一个地址，包含了两个信息：1. 纯地址 2. 地址的基类型

```c
// 定义指针变量
int *p => 基类型 *指针变量名;
int a =100;
// *p1 代表p1所指向的变量，也就是变量a
int *p1 = &a; // 可以初始化也可以不初始化，
printf("%d", *p1);
/*
上面 int *p1表示定义p1为整型指针变量，变量名为p1
p1 =  &a; 表示把a的地址赋予p1，这个时候p1就指向了a；
后面*p1代表p1所指向的对象，也就是a

即*p => 变量a，其中*号表示该变量是指针变量，*p1指变量p所只指向的变量(即实际值，也就是存储单元)
p => 变量a的地址
*/
```

### 指针变量赋值过程中发生了什么(以下面代码为例子)

```c
int a;
int *p=&a;
```

1. 定义一个指向整型类数据的指针变量 p
2. **把 p 整型变量地址&a 赋值给 p，使得 p 指向 a，其中&a 包含 2 个信息：纯地址和 a 的类型。赋值时会先检查&a 和 p 的类型是否相同，不相同不能赋值**

### 指针变量作为函数参数

1. 指针变量作为实参，是按值传递的, 数组除外
2. **不能通过调用函数来改变实参指针变量的值，但可以改变实参指针变量所指变量的值，数组除外**

```js
// 由上面给出的解释

// 1. 不能在所调用的函数里面直接更换指针变量的地址，如 int * a; a= b;
// 2. 能在函数里面直接使用 int a; a = *p，*p = 123; 即直接改变了指针变量所指变量的值
```

3. 假如 int a[3] = {1,2,3}, \*p =a; 则也可以用 p[i]打印出当前值

### 通过指针引用数组

```c
int a[10];
int *p;
p = &a[0]; // 或者p=a，两者等价
```

1. 如果指针变量 p1 和 p2 都指向同一数组，然后 p2-p1，结果是两个地址之差除以数组元素的长度，得出的结果代表了**元素之间相差的个数，可以得出两个元素间的相对距离**
2. 如果指针变量 p1 和 p2 都指向同一数组，然后 p2+p1，则无意义
3. 指针引用数组元素的方法
   - 下标法：a[i]
   - 指针法：\*(a+i)
4. 如果指针 p1 已指向数组中的某一个元素，则 p+1 指向同数组中的下一个元素,**程序执行 p+1 时并不是将 p 的值(地址)简单地加 1,而是加一个数组元素所占用的字节数。**
5. \*(a+i),\*(p+i),a[i]三者是等价的,**在编译时，就是按数组首元素地址加上相对位移量得到所找元素的地址**

```c
int a[5] = {1,2,3,4,5}
int *p;
p = &a[2]; // 或者p=a，两者等价
printf("%d", *(p+2)); // 打印5，p初始指向3
```

### 以变量名和数组名作为函数参数的比较

|           实参类型           |  变量名  |         数组名         |
| :--------------------------: | :------: | :--------------------: |
|        要求形参的类型        |  变量名  |    数组名或指针变量    |
|          传递的信息          | 变量的值 |  实参数组首元素的地址  |
| 通过函数调用能否改变实参的值 |   不能   | 能改变实参数组元素的值 |

### 通过指针引用字符串

1. 使用字符指针变量和字符数组的区别：
   - 字符指针变量中存放的是地址，而不是将字符串放到字符指针变量中
   - 对字符数组的赋值，有些可以赋值，有些则不行, 即**数组可以在定义时整体赋初值，但不能再赋值语句中整体赋值，指针变量除外**
   ```c
   // 不合法
   char str[14];
   str = "I love china";  // 不合法
   str[] = "I love china";  // 不合法
   // 合法
   char *a;
   a =  "I love china";
   ```
   - **数字符数组中个元素的值可以改变，但字符指针变量指向的字符串常来那个中的内容不可以被替代**数
   ```c
   char a[] = "House";
   char *b = " House";
   a[2] = r; // 合法
   b[2] = r; // 非法：字符串常量不能直接改变
   ```
   - **对字符指针变量，如果未初始化情况下，不能随便赋予内存单元，因为没有地址的内存单元可能会存在一个不可预料的值**
   ```c
   // 合法
   char str[10];
   scanf("%s", str);
   // 不合法
   char *a;
   scanf("%s", a);
   // 合法
   char *a,str[10];
   a= str;
   scanf("%s", a);
   ```
   - **字符数组是常量，不能加减。但字符指针变量可以加减**

### 易错地方

1. 输入两个值，按从大到小排列

```c
// 运行下面代码 输入5,9 打印出来的也是5,9
// C语言中实参变量和形参变量的数据传递是单项的值传递，用指针变量也要遵守这一情况
int main()
{
  void swap(int *p1, int *p2);
  int *z1, *z2, a, b;
  scanf("%d,%d", &a, &b);
  z1 = &a;
  z2 = &b;
  if (a < b)
  {
    swap(z1, z2);
  }
  printf("max=%d,min=%d\n", a, b);
  return 0;
}


// 正确
void swap(int *p1, int *p2)
{
  int temp;
  temp = *p1;
  *p1 = *p2;
  *p2 = temp;
}

// 错误
void swap(int *p1, int *p2)
{
  int *p;
  p = p1;
  p1 = p2;
  p2 = p;
}

// 出错
void swap(int *p1, int *p2)
{
  int *temp;
  *temp = *p1;
  p1 = *p2;
  p2 = *temp;
}
这里未给指针变量temp赋值，因此temp中并无确定的值(即地址不可预见)，所以temp指向的存储单元也是不可预见的，对*temp赋值就是向一个未知的存储单元赋值，而这个未知的存储单元里面可能存储着一个有用的数据，这样就有可能破坏系统的正常工作
```

## 提高部分

1. 多维数组的指针：每多一层地址，表示多一层数组，数组之间不像一维数组那样连续

```c
int a[3][4] = {{1,3,5,7}, {9,11,13,15}, {17,19,21,23}};
/**
 上面a是数组名，有3行，同时也代表着二维数组首元素的地址，首元素是由4个整型元素所组成的一维数组，因此a代表的是首行的的首地址
*/
a+1; // 代表a[1][0]的地址
a+2; // 代表a[2][0]的地址
int (*p)[4]; // 定义一个指向有4个元素的一维数组，如果有p=a+1; 则p指向a[1]的地址；,如果想到拿a[1][2]的话，就是*p[2]，因为前面p已经指向了a[1]的地址了，即*p=a[1],则*p[2] = a[1][2]
```

2. **指向函数的指针： 数据类型 (\*指针变量名)(函数参数表列);**

```c
int (*p)(int, int)
int getMax(int a, int b) {
  return a-b;
}
p = max; // 指针指向函数
(*p)(a,b); // 调用
```

3. **返回指针值的函数：类型名 \*函数名(参数表列);**

```c
// 返回指针值的函数
int *a(int x)
  {
    int *pt;
    pt = &x;
    return pt;
  }
  int *p;
  p = a(4);
  printf("%d", *p);
```

4. 指针数组：即数组里面的每一项都是指针/地址

```c
// int *p[4];
int a = 1; int *pa = &a;
int b = 2; int *pb = &b;
int c = 3; int *pc = &c;
int d = 4; int *pd = &d;
int e = 5; int *pe = &e;

int* arr1[5] = { &a,&b,&c,&d,&e };
int* arr2[5] = { pa,pb,pc,pd,pe };
printf("%d", *arr2[2]); // 打印3
```

5. 多重指针：即**指向指针的指针**

```c
int a = 100;
int *p1 = &a;
int **p2 = &p1;
int ***p3 = &p2;
printf("%d, %d, %d, %d\n", a, *p1, **p2, ***p3); // 打印 100,100，100,100
```

6. 总结：**定义指针型变量的时候，只要是\*号包含在括号内的，如(\*p)，那么就属于指向 xx 的指针变量**

| 定义         | 含义                                                      |
| ------------ | --------------------------------------------------------- |
| int i        | 定义整型变量 i                                            |
| int \*p      | p 为指向整型数据的指针变量                                |
| int a[n]     | 定义整型数组，它有 n 个元素                               |
| int \*p[n]   | 定义指针数组，它由 n 个指向整型数据的指针元素组成         |
| int (\*p)[n] | p 为指向含 n 个元素的一维数组的指针变量                   |
| int f()      | f 为返回整型的函数                                        |
| int \*p()    | p 为返回一个指针的函数，该指针指向整型数据                |
| int (\*p)()  | p 为指向函数的指针，该函数返回一个整型值                  |
| int \*\*p    | p 是一个函数指针，它指向一个指向整型数据的变量            |
| void \*p     | p 是一个指针变量，基类型为 void(空类型), 不指向具体的数据 |

### 指针运算小结

1. 指针变量的空值 NULL：指针变量可以有空值，即该指针变量不指向任何变量，NULL 是一个符号常量，在 stdio.h 头文件里面已经对 NULL 进行了定义,**任何指针变量或地址都可以与 NULL 做相等或不相等的比较**

```c
if(p == NULL)...
```

2. 指针运算小结
   - 例如：p++,p--,p+i,p-i 等均是指针变量加(减)一个整数。将该指针变量的值(地址)h 和它指向的变量所占用的内存单元字节数相(减)
   - 两个指针变量可以相减，相减之差是两个指针之间的元素个数
   - 两个指针变量可以比较，指向前面元素的指针变量小于后面元素的指针变量

{2,3,4,5}, **q = p，则\*p[0] = 1, **(q+2) = 4, A
