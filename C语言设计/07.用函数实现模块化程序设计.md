### 函数的特性

1. 从用户使用角度看，函数分为**库函数**和**用户自定义函数**
2. 从函数的形式看，函数分**有参函数**和**无参函数**

### 函数定义

```c
int Column; // 定义全局变量
static int Column // 静态全局变量，只允许当前文件引用，不允许外部文件引用;
int max(int x, int y) {
  if(x > y) return x;
  else return y;
}

int main()
{
  int max(int x, int y); // 函数声明形式1
  int max(int, int) // 函数声明形式2
  printf("%d\n", max(3, 4));
}
```

### 函数调用过程(以上面函数定位为例)

1. 在定义函数中指定的形参，在未出现函数调用时，他们并不占用内存中的存储单元，在发生函数调用时，函数 max 中的形参被分配内存单元
2. 将实参对应的值传递给形参
3. 在执行 max 函数期间，由于形参已经有值，就可以进行有关的运算
4. 通过 return 语句将函数值带回到主调函数
5. 调用结束，形参单元被释放
6. 调用函数的方式：
   - 函数语句：pinrt_star()
   - 函数表达式：c = 2 \* max(a,b);
   - 函数参数:printf("%d", max(a,b));

### 函数调用(普通调用)

重点：**函数形参是按值传递的(传整个数组除外，数组是按地址传递)，就算函数内改变原来参数的值，原来参数的值也不受影响（包括传数组某一项）**，

1. 函数定义：**指对函数功能的确立**，它是一个完整的，独立的函数单位。
2. 函数声明的作用：把函数名，函数参数的个人和参数类型等信息通知编译系统，编译系统能据此识别函数并检查函数调用是否合法。
3. 函数声明的说明: 如果被调用函数的定义出现在 main 函数之前，那可以不加函数声明
4. 函数原型：就是**函数声明**

```js
/**
函数调用过程范例：
void main() {
   int max(int, int); // 函数声明简写，不写参数名，只写参数类型
   int max(int u, int v) // 函数生命简写，参数名不用x,y，直接使用u,v
}
int max(int x, int y) { // 形参x,y不占内存中的存储单元
   if(x>y) {
      return x;
   } else {
      return y;
   }
}
1. 在定义函数中指定的形参，在未出现函数调用时，他们并不占内存中的存储单元，直到函数发生调用时，函数max中的形参才被分配内存单元
2. 将实参对应的值传递给形参
3. 在执行max期间，由于形参已经有值，就可以进行有关的运算
4. 通过return语句将函数值带回到主调函数
5. 调用结束后，形参单元被释放
 */
```

### 函数调用(传整个数组情况)

1. 用变量名或数组元素名作函数参数时，传递的是变量的值，用数组名作函数参数时，传递的是数组首元素的地址。
2. 由于数组名代表数组首元素的地址，因此只是将数组的首元素的地址传输给对应形参

### 函数的嵌套调用和递归调用

递归调用：在调用函数过程中直接或间接地调用该函数本身，称为函数的递归调用。

### 多维数组作为函数实参

1. 在被调用函数中对形参数组进行声明时，可以指定每一维的大小，也可以省略第一维的大小说明, 但不能只指定第一行
   ```c
   // 合法
   float fn(float arr[5][5])
   float fn(float arr[][5])
   // 不合法
   float fn(float arr[][])
   float fn(float arr[4][])
   ```

### 变量的作用域和生存期

1. 变量的作用域：指**变量的有效的范围**，分为局部变量和全局变量
1. 变量的生存期：指**变量存在的时间**
1. 内部变量/局部变量：**在函数或复合语句中定义的变量，只在本函数或符合语句内范围有效**。使用时才分配存储单元，不占用空间。也叫**动态存储方式**,函数内的变量，函数调用完释放回收空间
   - 主函数内的变量也是局部变量
   - 不同函数中可以使用相同名字的变量，他们互不干扰
   - 形参也是局部变量
   - 在函数内部可以在复合语句中定义变量，这些变量只在复合语句中有效
   - 复合语句：**将两条或以上的雨具用{}括起来的语句**
1. 外部变量/全局变量：在函数外定义的变量，提前分配存储单元，占用空间。也叫**静态存储方式**，在函数外定义的变量，程序运行过程中都存在。

```c
// 全局变量定义
#include <stdio.h>
int Row, Column;

void main() {

}
```

### 变量的存储类别

1. 每一个变量和函数都有两个属性：**数据类型**和**数据存储类别**，定义变量时除了需要定义数据类型外，还可以指定定义其存储类别

### 变量的存储类别分类

1. auto: 声明自动变量，比如函数形参和在函数中定义的变量，在函数调用结束时就自动释放这些存储空间，所以这类变量被称为**自动变量**，auto 关键字可以省略。
2. static：声明静态变量，函数中的变量在调用结束后不消失而保留原值。该变量在整个程序运行期间都不释放空间(缩略图 239)，静态局部变量不赋初值时，会自动赋初值 0(对数值型变量)或空字符(对字符变量)，如果希望外部变量只限于被本文件引用，只能用于本文件的外部变量，称为**静态外部变量**
   - static 对局部变量：使变量由动态存储改变为静态存储方式。
   - static 对全局变量：使全局变量局部化，只能被本文件引用

```c
static int f = 1; // 只初始化一次，在程序运行期间都不释放空间，不能被外部其他文件所引用
```

3. register：寄存器变量。一些频繁使用的变量(比如循环 10000 次)，每次循环都要引用局部变量，这种频繁操作的变量每次存储都会花费很多时间，为提高效率直接放 cpu 的寄存器中，增加存取速度

```c
register int f;
```

4. extern：**外部变量声明**，
   - 作用 1：**在一个文件内扩展外部变量的作用域**， 因为全局变量的作用域只在于从定义点到文件结束(全局变量不一定写在最头部)，这样会导致上面的函数引用不到全局变量(缩略图 241)
   - 作用 2：**将外部变量的作用域扩展到其他文件**

```c
extern b;
```

### 内部函数和外部函数

1. 内部函数：又称**静态函数**，只能被本文件中的其他函数所调用，不同文件中有同名的内部函数互不干扰，比如 static int fun(int a, int b);
2. 外部函数：定义时在函数处加 extern 的函数，可以被其他文件调用，比如 extern int fun(int a, int b);

```c
// 引用外部函数
int main() {
  extern void fn1(char str[]);
  extern void fn2(char str[]);
}
```
