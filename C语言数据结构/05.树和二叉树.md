### 树

1. 定义：树的 n(n>=0)个结点的有限集，它或为空树或为非空树
   **非空树的特点**
   - 有且仅有一个称之为根的结点
   - 除根结点以外的其余结点可分为 m(m>0)个不相交的有限集 T1，T2，...Tm，其中每个集合本身又是一棵树，并且称为根的子树(SubTree)。
   - n>0 时根结点是唯一的
   - m>0 时，子树的个数没有限制，但他们**一定互不相交**

### **树的基本术语**

![树](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/tree.png#pic_center)

1. **结点**:树中的一个独立单元。包含一个数据元素及若干指向其子树的分支，如图 5.1(b)中的 A、B、C、D 等。
2. **结点的度**:结点拥有的子树数称为结点的度。例如，A 的度为 3,C 的度为 1,F 的度为 0。
3. **树的度**:树的度是树内各结点度的最大值。图 5.1 (b）所示的树的度为 3。
4. **叶子**:度为 0 的结点称为叶子或终端结点。结点 K、L、F、G、M、I、J 都是树的叶子。
5. **非终端结点**:度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。
6. **双亲和孩子**:结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B 的双亲为 A，B 的孩子有 E 和 F。
7. **兄弟**:同一个双亲的孩子之间互称兄弟。例如，H、I 和 J 互为兄弟。
8. **祖先**:从根到该结点所经分支上的所有结点。例如，M 的祖先为 A、D 和 H。
9. **子孙**:以某结点为根的子树中的任一结点都称为该结点的子孙。如 B 的子孙为 E、K、L 和 F。
10. **层次**:结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加 1。
11. **堂兄弟**:双亲在同一层的结点互为堂兄弟。例如，结点 G 与 E、F、H、I、J 互为堂兄弟。
12. **树的深度**:树中结点的最大层次称为树的深度或高度。图 5.1 ( b)所示的树的深度为 4。
13. **有序树和无序树**:如果将树中结点的各子树看成从左至右是有次序的（即不能互换),则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
14. **森林**:是 m (m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此,也可以用森林和树相互递归的定义来描述树。
15. **树的高度、深度、层的区别**：高度和深度从 0 开始，层从 1 开始
    ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/ceng.png)
    - 高度：从下往上数，从 0 开始
    - 深度：从上往下数，从 0 开始
    - 层：根节点为第一层，往下依次递增

### 树的存储结构

1. 双亲表示法：每个结点除了数据域 data 之外，还附设一个 parent 域用以指示其双亲结点的位置。

**好处**：很容易求结点的双亲，但是求结点的孩子时需要遍历整个结构

```c
typedef struct BitNode
{
  int data;
  int parent;  // parent为父结点的index下标, 根节点的parent为-1
  struct BitNode *lchild, *rchild;
} BitNode;
```

2. 孩子表示法：孩子表示法存储普通树采用的是 "顺序表+链表" 的组合结构，其存储过程是：从树的根节点开始，使用顺序表依次存储树中各个节点。需要注意，与双亲表示法不同的是，孩子表示法会给各个节点配备一个链表，用于存储各节点的孩子节点位于顺序表中的位置。如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。

**好处**：**便于那些涉及孩子的操作的实现**，比如查找某个结点的某个孩子，或者找某个结点的兄弟

```c
typedef struct BitNode {
   ElemType data;
   CLNode *child; // 孩子节点链表，以上面的二叉树为例 A.CLNode => B -> C -> D，B.CLNode => E -> F， F.CLNode -> null
}
```

[孩子表示法](https://www.bilibili.com/video/BV1x24y1i7gY/?spm_id_from=333.337.search-card.all.click&vd_source=43e2e4000f452d9f3fbf8591d4a6a948)
参考：http://data.biancheng.net/view/197.html

3. 孩子兄弟法：又叫二叉树表示法、二叉链表表示法，即以二叉链表作为树的存储结构。链表中节点的两个链域分别指向该节点的第一个孩子节点 firstChild 和下一个兄弟节点 nextSibling

**好处**：和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树算法实现对树的操作

```c
typedef struct BitNode {
   ElemType data;
   CBNode *firstChild, *nextSibling;
}
```

### 二叉树

1. 定义：树的 n(n>=0)个结点所构成的集合，它或为空树(n=0)或为非空树
   **非空二叉树的特点**
   - 有且仅有一个称之为根的结点
   - 除根结点以外的其余点分为两个不交的子集 T1 和 T2，分别称为 T 的左子树和右子树，且 T1 和 T2 本身又都是二叉树。
   - 二叉树每个结点至多只有两棵子树(即二树中不存在度大于 2 的结点)
   - 二叉树的子树有左右之分，其次序不能任意颠倒
2. 由第一点可知：二叉树有 5 种形态：1. 空二叉树 2. 仅有根节点的二叉树 3. 右子树为空的二叉树 4.左子树为空的二叉树 5. 左右子树均非空的二叉树
3. **二叉树的性质**

   1. 在二叉树的第 i 层上至多有 2^(i-1)个结点(i>=1)
   2. 深度为 K 的二叉树至多有(2^k)-1 个结点
   3. 对任何一棵二叉树 T，如果其终端结点数为 N0，度为 2 的结点数为 N2，则 N0 = N2+1

   - ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/tree_type.png)

   4. 斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。这两者统称为斜树。
   5. **满二叉树**：深度为 K 且含有(2^k)-1 个结点的二叉树
   6. **完全二叉树(从上到下次顺序相同，不存在空位)**：深度为 k 的有个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应时，称之为完全二叉树。

      - 完全二叉树的叶子结点只可能在层次最大的两层上出现
      - 对任一结点，若其右分支下的子孙的最大层次为 ，则其左分支下的子孙的最大层次必为 1 或 1+1。图 5.6 中(c)和(d)不是完全二叉树。
      - 具有 n 个结点的完全二叉树的深度为(log2n)+1,(底数 2，指数 n，log 以 2 为底 n 的对数)，
      - 如果对一颗有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i 有
        1. 如果 i=1，则结点 i 是二叉树的根，无双亲，如果 i>1，其双亲是结点 i/2
        2. 如果 2i>n, 则结点无左孩子；否则其左孩子是结点 2i
        3. 如果 2i+1>n,则结点 i 无右孩子；否则其右孩子是结点 2i+1

### 二叉树的存储结构

1. 顺序存储：顺序存储仅适用于完全二叉树。因为，按树的结构可以会存在空子树，空子树的每个结点都会占用存储空间，会造成存储空间的浪费
2. 链式存储：对于非完全二叉树比较适合

```c
typedef struct BitNode
{
  int data;
  struct BitNode *lchild, *rchild;
} BitNode;
```

3. **二叉树的链式存储和遍历方式**

三种遍历方式：可以记序为根，即先根遍历，中根遍历，后根遍历

1. 先序遍历(根左右)
2. 中序遍历(左根右)
3. 后序遍历(左右根)
4. 层序遍历(从上到下，从左到右)
5. **只有知道树的先序遍历和中序遍历，或者树的中序遍历和后序遍历，才能确定一颗二叉树**

[参考](https://blog.csdn.net/weixin_64916311/article/details/130157918)

### 线索二叉树

1. 定义：将传统的二叉链表的空指针指向其前驱或者后继的指针，这样就可以像遍历单链表那样方便地遍历二叉树，以这种结点构成的二叉列表称为线索链表。加上线索的二叉树称为线索二叉树。
2. 线索化：对二叉树以某种次序遍历，实其变为线索二叉树的过程称做是线索化
3. **出现的问题？**：无法知道某一节点的 lchild 是指向做孩子还是前驱，rchild 是指向右孩子还是后继，对此需要设置一个区分标志，即设置两个标志域**ltag**和**rtag**，只存放 0 或 1 数字的布尔型变量
   - ltag 为 0 时指向该结点的左孩子，为 1 指向前驱
   - rtag 为 0 时指向该结点的右孩子，为 1 指向后驱
4. **如何作用**：
   1. 若结点的左孩子不为空，LChild 指针域仍指向其左孩子，否则，LChild 指针域指向遍历过程序列的前驱结点。
   2. 若结点的右孩子不为空，RChild 指针域仍指向其右孩子，否则，RChild 指针域指向遍历过程序列的后继结点。
   3. 对于 Ltag 和 Rtag 的标志域的定义：
      Ltag = 0 时，LChild 域指向结点的左孩子。
      Ltag=1 时， LChild 域指向结点的遍历前驱。
      Rtag=0 时，RChild 域指向结点的右孩子。
      Rtag=1 时，RChild 域指向结点的遍历后继。

```c
// 线索二叉树结构
typedef struct Node
{
   TypeData data;
   int Ltag,Rtag;
   struct Node*LChild;
   Struct Node*RChild;
} BiTree, *BiThrTree;
```

**好处**：加快查找结点的前驱或后继的速度

## 森林，树与二叉树的转换步骤

https://blog.csdn.net/weixin_44162361/article/details/119044059

### 树转换为二叉树

1. 加线，在所有兄弟节点之间加一条连线
2. 去线，对树种每个结点，只保留它与第一个孩子结点的连线，删除他与其他孩子结点间的连线
3. 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。如右图所示。

### 森林转换为二叉树

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/bz1.png)

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/bz2.png)

1. 把森林中的每颗树转换为二叉树
2. 第―棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。如右图所示。

### 二叉树转换为树

1. 加线
2. 去线
3. 层次调整

### 习题

**选择题**

1. A 对
2. D 对
3. C，错应该是 D：501 个 因为该二叉树从第一层到倒数第二层共有(2^k)-1 共 511 个 1001-511 = 490 ，490/2=245, 256-24 = 11,490+11=511 个

```c
/*
一棵完全二叉树上有 1001 个结点，其中叶子结点的个数是()
A.250
B.254
C.500
D.501

*/
```

4. C 对
5. A 对
6. C 对，这题要回头去看
7. C 对，
8. A ?
9. D 对
10. B 错 C
11. A 错 B
12. C 对
13. A 对
14. A 错 C，
15. B 错 A，如 05.哈夫曼树的最上面的图片，呈现右偏的话 就不是一个完全二叉树
