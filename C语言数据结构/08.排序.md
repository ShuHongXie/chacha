## 排序

1. 排序：排序是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作。
2. 内部排序和外部排序：
   - **内部排序**：指的是待排序记录全部存放在计算机内存中进行排序的过程;
   - **外部排序**：指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过。
3. 内部排序方法的分类
   - 插入法：插入排序。折半插入排序，希尔排序
   - 交换类：冒泡排序，快速排序
   - 选择类：简单选择排序，树形选择排序和堆排序。
   - 归并类：归并排序
   - 分配类：基数排序
4. 排序算法效率的评价指标：**执行时间**，**辅助空间**
5. [所有排序参考](https://blog.csdn.net/PoGeN1/article/details/130462042)

## 插入排序

### 直接插入排序

1. 定义：插入排序算法是所有排序方法中最简单的一种算法，其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据。
2. 时间复杂度：O(n^2)
3. 空间复杂度：O(1)，只需要一个记录的辅助空间
4. [直接插入排序参考地址](http://m.biancheng.net/view/3439.html)
5. 核心过程：每次只对第 i 个进行排序，保证从 0 到 i 个是顺序的，不像冒泡，一次性对比全部
6. 算法特点：
   - 稳定排序
   - 算法简便，且容易实现
   - 也适用于链式存储结构，只是在单链表上无需移动记录，只需修改相应的指针。
   - 更适合于初始记录基本有序(正序）的情况，当初始记录无序,n 较大时,此算法时间复杂度较高，不宜采用。

```c
/**
   若一组记录的排序码为(46,79,56,38,40,84)，则利用直接插入排序的从小到大排，求排序的每一轮过程
   -----解答-----------
   后index个，和index前面的比，如果比前面的某个大，就插入到那一个的位置，其他的向后移动
   第一轮：index=1时，46,79,56,38,40,84
   第二轮：index=2时，46,56,79,38,40,84
   第三轮：index=3时，38,46,56,79,40,84
   第四轮：index=4时，38,40,46,56,79,84
   第五轮：index=5时，38,40,46,56,79,84
*/
```

### 折半插入排序

1. 定义：跟直接插入排序一样，只是增加了一个折半查找法判断插入位置
2. 时间复杂度，空间复杂度：和直接插入排序一样
3. 算法特点：
   - 稳定排序
   - 因为要进行折半查找，所以只能用于顺序结构，不能用于链式结构。
   - 适合初始记录无序、n 较大时的情况。

### 希尔排序

1. 定义：希尔排序又称**缩小增量排序**，是对直接插入排序的改进
2. 时间复杂度：O(N^(3/2))
3. 空间复杂度： O(1)
4. 间隔划分公式：i = m/3+1，不是划分为 i，而是间隔为 i
5. 算法特点:
   - 记录跳跃式地移动导致排序方法是不稳定的。
   - 只能用于顺序结构，不能用于链式结构。
   - 总比较数和移动次数都比直接插入排序少，n 越大时效果越明显。所以适合初始记录无序，n 较大时的情况。
6. [希尔排序参考链接 1](https://baijiahao.baidu.com/s?id=1719645128431014366&wfr=spider&for=pc)
7. [希尔排序参考链接 2](https://blog.csdn.net/qq_43471489/article/details/125573835)

## 交换排序

### 冒泡排序

1. 时间复杂度：O(n^2)
2. 空间复杂度： O(1)
3. 算法特点:
   - 稳定排序
   - 可用于链式结构
   - 移动记录次数较多，算法平均时间性能比直接插入排序差。当初始记录无序,n 较大时，此算法不宜采用。
   - **可以说是效率最低的排序方法**

```c
/**
   若一组记录的排序码为(46,79,56,38,40,84)，则利用冒泡排序的从小到大排，求排序的每一轮过程
   -----解答-----------
   前一个和后一个比，如果前面比后面大就交换位置
   第一轮：46,56,38,40,79,84
   第二轮：46,38,40,56,79,84
   第三轮：38,40,46,56,79,84
*/
```

### 快速排序

1. 定义：由冒泡排序改进而得，在冒泡排序过程中，只对相邻的两个记录进行比较,因此每次交换两个相邻记录时只能消除一个逆序。如果能通过两个(不相邻)记录的一次交换，消除多个逆序，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序。
2. 时间复杂度：O(nlog2^n)
3. 空间复杂度： 最好情况下 O(log2^n)，最坏情况下 O(n^2)
4. [快速排序参考链接](https://blog.csdn.net/m0_61545891/article/details/122588499)

```c
/**
   若一组记录的排序码为(46,79,56,38,40,84)，则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为
   -----解答-----------
   原则： L的值要大于才能移动，R的值要小于才能移动
   假定下标为46，此时L=1，值46，R=6，值84
   1. 从R开始，R值84>46，继续向左移动到R=5，值40<46，L和R交换位置，此时L值为40，R为46，呈现(40,79,56,38,46,84)
   2. 上面R调换过，接下来从L开始，L+1=2，值为79，79>46，所以L和R调换位置，呈现(40,46,56,38,79,84)
   3. 上面L调换过，接下来从R开始，R-1=4, 值为38，38<46，所以L和R调换位置，呈现(40,38,56,046,79,84)
   4. 上面R调换过，接下来从L开始，L+1=3，值为56，56>46，所以L和R调换位置，呈现(40,38,46,56,79,84)
   5. 上面L调换过，接下来从R开始，R=1=3，左右指针重合，不做计算，第一轮最终值为(40,38,46,56,79,84)
*/
```

## 选择排序

### 简单选择排序/直接选择排序

1. 时间复杂度：O(n^2)
2. 空间复杂度： O(1)
3. 算法特点:
   - 稳定排序
   - 可用于链式结构
   - 移动次数较少
   - 总体上要略优于冒泡排序
4. [简单选择排序参考链接](https://blog.csdn.net/weixin_52811588/article/details/126486829)

```c
/**
   若一组记录的排序码为(46,79,56,38,40,84)，则利用直接插入排序的从小到大排，求排序的每一轮过程
   -----解答-----------
   每次找出剩余index里面的最小值，将最小值与当前index交换位置
   第一轮：index=0时, 38,79,56,46,40,84
   第二轮：index=1时, 38,40,56,46,79,84
   第三轮：index=2时, 38,40,46,56,79,84
*/
```

### 堆排序

1. ​ 堆（heap）：一个完全二叉树，每个节点都比子节点的值大或小
2. 大根堆：每个节点的值都比其子节点大
3. 小根堆：每个节点的值都比其子节点小
4. 算法特点:
   - 是不稳定排序
   - 只能用于顺序结构，不能用于链式结构
   - 记录多时相对快速排序，较为高效
5. [堆排序参考链接](https://blog.csdn.net/Alian_1223/article/details/127841954?spm=1001.2014.3001.5502)
6. [堆排序参考链接](https://blog.csdn.net/weixin_45891612/article/details/128087620)

```c
/**
   如何构造大小根堆？
   1. 找到最后一个非叶子节点，从最后一个非叶子节点开始，从右至左，从下至上进行调整。
   2. 调整规则：找到该节点和他的所有子节点。如果该节点中存的值是找到节点值中的最大值，则不进行调整。如果不是，就将该节点的值和最大值进行交换，然后递归的调整和该节点交换值得的个节点。

   已知一组待排记录的关键字序列为(15，11，17，59，14，35，13，17，24，84)，请给出对应的小根堆序列。

*/
```

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311101630088.png)

## 归并类

### 归并排序

1. 定义：将两个或两个以上的有序表合并成一个有序表的过程。
2. 时间复杂度：O(nlog2^n)
3. 空间复杂度 O(n)
4. 算法特点:
   - 是稳定排序
   - 可用于链式结构，且不需要附加存储空间，但赌鬼实现时仍需要开辟相应的递归工作栈
5. [归并排序参考链接](https://blog.csdn.net/qq_43575801/article/details/127560973)

```c
/*
二分归并排序的解法
假设含有n个序列，对n个序列两两归并，得到[n/2]个长度为2或1的有序子序列；再两两归并，不断重复，直至得到一个长度为n的有序序列位置，看下面例题

1. 将一组键值{80,50,65,13,86,35,96,57,39,79,59,15}应用二路归并排序算法，写出各躺的结果
第一趟：[50,80],[13,65],[35,86],[57,96],[39,79],[15,59]
第二趟：[13,50,65,80],[35,57,86,96],[15,39,59,79]
第三趟：[13,35,50,57,65,80,86,96],[15,39,59,79]
第四趟：[13,15,35,39,50,57,59,65,79,80,86,96]
*/
```

## 分配类

### 基数排序

1. [基数排序参考链接](https://blog.csdn.net/Alian_1223/article/details/128016434)
2. 算法特点:
   - 是稳定排序
   - 可用于链式结构，也可用于顺序结构
   - 时复杂度可以达到 O(n)
   - 使用条件有严格的要求：需知道各级关键字的主次关系和各级关键字的取值范围

## 各排序方法简介表

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202309221538006.png)

1. 不稳定的算法的记忆法：**快速选择堆希尔**

## 结论

1. 当待排序的记录个数 n 较小时，n 和 nlogan 的差别不大，可选用简单的排序方法。而当关键字基本有序时，可选用直接插入排序或冒泡排序，排序速度很快，其中**直接插入排序最为简单常用，性能最佳**。
2. 当 n 较大时，**快速排序**最佳

### 习题

**选择题**

1. C，对
2. D，对
3. B，对
4. D，对
5. C，对
6. B，对
7. C，对
8.
9. C，对
10. C，对
11.
12. C，对
13. C，对
14. B，对
15. A，对
