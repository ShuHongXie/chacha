### 查找

1. **查找表**：由同一类型的数据元素构成的集合。
2. **关键字**：关键字是数据元素(或记录)中某个数据项的值，用它可以标识一个数据元素(或记录)。若关键字可以唯一地标识一个记录，则称此关键字为**主关键字**，比如某个字段的 id。反之，以识别若干记录的关键字为**次关键字**，比如某张表表的涨跌幅(可重复)。
3. **查找**：查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称**查找成功**;若表中不存在关键字等于给定值的记录，则称**查找不成功**，此时查找的结果可给出一个“空”记录或“空”指针。
4. **动态查找表和静态查找表**：若在查找的同时对表做修改操作(如插入和删除),则相应的表称之为**动态查找表**，否则称之为**静态查找表**。换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功返回;否则插人关键字等于给
   定值的记录。
5. **平均查找长度**：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法，在查找成功时的平均查找长度

### 线性表的查找

1. 顺序查找：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功;反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。
2. 折半查找：又称**二分查找**，折半查找必须采用顺序存储结构, 时间复杂度为 O(log2^n)
3. 分块查找：又称**索引顺序查找**，性能介于顺序查找和折半查找之间
   ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/block_search.png)
   - 次查找除表本身外，还需建议一个"索引表"，其中包含两项内容：关键字项(其值为该子表内的最大关键字)和指针项(指示该子表的第一个记录在表中位置)，第 n 个子表中所有记录的关键字均大于第 n-1 个表中的最大关键字
   - 查找过程：**先确定待查记录所在的快，然后在块中顺序寻找**
   - 可用方法：**由于由索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是任意排列的,则在块中只能是顺序查找。**
   - 优点：由于块内无需，所以插入和删除比较容易，无需大量移动。
   - 缺点：需要额外增加一个索引表的存储空间并对初始索引表进行排序运算。

### 树表的查找------二叉排序树

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/ecpxs.png)

1. 二叉排序树：又称**二叉查找树**，它或是一颗空树，或是具有下列性质的二叉树：
   - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值;
   - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;
   - 它的左、右子树也分别为二叉排序树。
   - 原理：
2. **二叉排序树查找过程**：将给定值 key 与根节点进行比较，大于则递归查找其右子树，小于则递归查找其左子树，相同直接返回根结点地址；
3. **二叉排序树插入过程**：若二叉排序树为空，则待插入节点插入到空树中，如果非空则将结点与根节点进行比较，大于结点插入右子树，小于结点插入左子树
4. **二叉排序树创建过程**：**对某个结点进行二叉塑造，一个数小于该节点则作为该结点的左子树，大于该节点作为该节点的右节点，不断塑造下去(递归)，形成二叉排序树**，接着对二叉排序树进行中序遍历，就得到了一个顺序表
5. 优缺点：
   - 优点：插入和删除的时间性能比较好
   - 缺点：查找性能差

### 树表的查找------平衡二叉树(AVL)树

1. 平衡二叉树：平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：
   - 左子树和右子树的深度之差的绝对值不超过 1
   - 左子树和右子树也是平衡二叉树
2. **平衡因子**：二叉排序树上结点的左子树和右子树的深度之差只能是-1,0，1；
3. 最小不平衡树：距离插入结点最近的，切平衡因子的绝对值大于 1 的结点为根的子树
4. 优缺点：
   - 优点：弥补了二叉排序树的查找性能，使查找性能更好
   - 缺点：无

### 树表-多路查找树(B-树前置知识)

1. 定义：其每一个结点的孩子数可以多余两个，且每个结点处可以存储多个元素
2. 2-3 树：每个结点都具有 2 个或 3 个孩子，一个 2 结点包括一个元素和两个孩子，一个 3 结点包括一小一大两个元素和三个孩子

### 树表的查找------B-树 => B 杠树

1. B-树：一棵 m 阶的 B-树，或为空树,或为满足下列特性的 m 叉树:
   1. 树中每个结点至多有 m 棵子树;
   2. 若根结点不是叶子结点，则至少有两棵子树;
   3. 除根之外的所有非终端结点至少有 m/2 棵子树;
   4. 所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点（失败结点并不存在，指向这些结点的指针为空。引入失败结点是为了便于分析 B-树的查找性能);
   5. 所有的非终端结点最多有 m-1 个关键字
2. 特点：平衡，有序，多路

### 树表的查找------B+树

1. B+树是 B-树的变形树，更适合文件索引系统

------------------从 B-树开始看

### 散列表(哈希表 hash table)的查找

1. **散列查找法**：又称**杂凑法，散列法**
2. 术语定义：
   - **散列技术**：在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f （( key)。查找时，根据这个确定的对应关系找到给定值
   - **散列函数和散列地址**:在记录的存储位置 p 和其关键字 key 之间建立一个确定的对应关系 H，使 p= H(key)，称这个对应关系 H 为散列函数，p 为散列地址。
   - **散列表**：一个有限连续的地址空间。通常是一个数组，散列地址是数组的下标。即**存储位置=f(关键字)**
   - **冲突和同义词**：对不同的关键字可能得到同一散列地址。即 k1≠k2,而 H(k1)=H(k2)，称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，k1 和 k2 互称为同义词
3. 散列表的构造方法：
   - **数字分析法**：**事先必须明确知道所有的关键字每一位上各种数字的分布情况**。
   - 平方取中法：对关键字取平方再抽取中间 3 位。适**合不知道关键字的分布，而位数又不是很多的情况。**
   - 折叠法：对关键字从左到右分割成位数相等的几部分，然后叠加求和，按散列表表长，取后几位作为散列地址。**适合关键字位数较多的情况**
   - **除留余数法**：f(key) = key mod p (p<=m)
4. 散列表处理冲突的方法：
   - **开放地址法**：所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到,并将记录存入。通常把寻找“下一个”空位的过程称为**探测**,
     1. 公式：Hi = (H(key)+di)%m
     2. **堆积/二次聚集**：在处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象
   - **链地址法**：链地址法的基本思想是:把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有 m 个散列地址就有 m 个单链表，同时用数组 HT0…m-1]存放各个链表的头指针，凡是散列地址为 i 的记录都以结点方式插入到以 HT[i]为头结点的单链表中。

### 习题

**选择题**

1. D
2. D
3. C
4. D，错：折半查找分析时，不要使用代码来分析，用画图分析，第几个就是第几个，而不是数组里面的从 0 开始算
5. B
6. C
7. C
8.
9. C
10. A
11.
12. C
13. B
14.
15.
