### 串

1. 定义：**串(或字符串)是由零个或多个字符组成的有限序列**。一般记为 s="a1a2a3...an"，**串中字符的数目 n 称为串的长度**，零个字符的串称为**空串**，长度为 0。
2. 特性：串中任意个连续字符组成的子序列成为该串的**子串，串是自身的子串**，包含子串的串相应地成为**主串**，通常称字符在序列中的序号成为该字符在串中的**位置**。
3. 空格串：由一个或多个空格组成的串" "成为**空格串**
4. 如何判断串是否相等？：**两个串长度相等，并且各个对应位置的字符都相等**
5. 串的链式存储和顺序存储：对于串来说，顺序存储比链式存储灵活，性能也比链式存储好。
6. 前缀：字符串的子串中从原串最前面开始的子串，如 abcdef 的前缀有：a,ab,abc,abcd,abcde
7. 后缀：字符串的子串中在原串结尾处结尾的子串，如 abcdef 的后缀有：f,ef,def,cdef,bcdef
8. 子串：串中任意个连续字符组成的子序列称为该串的子串。如"abcdef"的子串有：""、"a"、"ab"、"abc"、"abcd","abcde"和"abcdef"等
9. 真子串：指不包含自身的所有子串。

### 串的模式匹配算法

子串的定位运算通常称为串的**模式匹配**或**串匹配**

1. **BF 算法(暴力算法)，也叫朴素的模式匹配算法**
   过程：以 0 为起点

   1. 指定一个主串 S 和匹配模式子串 T，初始化 pos 为主串 S 的开始索引，初始化 j=1 为子串 T 的开始索引
   2. pos 和 j 开始比较，如果相同则索引相加，如果不相同，pos = pos - j + 1, j 重置为 0
   3. 参考 string1.c 文件的 getIndex1 函数

时间复杂度：最好情况 O(n) 平均 O(m+n) 最坏情况 O(m\*n)

2. **KMP 算法，也叫改进的模式匹配算法\***：参考：https://blog.csdn.net/Marco458748194811/article/details/121799921
3. 两者比较：BF 算法实现简单，但存在回溯，效率低，时间复杂度为 O(m\*n)。KMP 算法对 BF 算法进行改进，消除回溯，提高了效率，时间复杂度为 O(m + n)。
4. [求 KMP 算法计算 next 数组和 nextval 数组](https://blog.csdn.net/qq_50595984/article/details/120424647)

```c
/**
   next数组的求解方法：
   根据当前next求前面的最长公共前后缀，如果有公共前后缀，就根据前缀的位置+1，没有公共前后缀则为1

   以abcabcacb为例： 011123451
   1. 开始ab的next数组默认设为01
   2. 走到c，c向前追溯，发现没有找到公共前后缀，则置为1，此时，next数组为011
   3. 走到a，a向前追溯，发现没有找到公共前后缀，则置为1，此时next数组为0111
   3. 走到b，b向前追溯，发现找到最长公共前后缀ab，则在前缀b的基础上加1，此时next数组为01112
   ...

   nextval求解方法：
 */
```

### 数组

1. 定义：由类型相同的数据元素构成的有序集合，每个元素称为数组元素
2. 数组的寻址公式:
   - L => 存储单元 n =>数组长度 j => 二维数组 LOC 的第二个参数
   - A[m,n] => m 代表行，n 代表列
   - LOC(i,j) = LOC(0,0) + (n\*i+j)
   - 其中 LOC(i,j)是 aij 的存储位置；LOC(0,0)是 a00 的存储位置，也称为基地址或基址
3. [寻址公式(对上面的补充):](https://www.cnblogs.com/gmengshuai/p/13976038.html)
4. 一些需要辩解清的点：

```c


/*
比如以一个二维数组A[0..m-1, 0..n-1]，a00代表第一行第一列
则任意位置aij的位置LOC(i, j) = LOC(0,0)+(n*i+j)

比如以一个二维数组A[1..m, 1..n]，基地址a11代表第一行第一列,
则任意位置aij的位置LOC(i, j) = LOC(0,0)+((n-1)*i+j)

*/
```

### 特殊矩阵的压缩存储

1. 对称矩阵，n 阶矩阵 A 满足 aij=aji，则成为**n 阶对称矩阵**
2. 三角矩阵，
3. 对角矩阵
4. 稀疏矩阵

### 广义表

1. 定义：广义表是线性表的推广，一般基座 LS=(a1,a2,...an),其中 n 是其长度(1<=i<=n)，**ai 可以是单个元素，也可以是广义表，分表称为广义表的原子和子表**。习惯上用大写字母表表示广义表，用小写字母表示原子。

   - 当 ai 为单个元素时，称作广义表的**原子**
   - 当 ai 为广义表时，称作广义表的**子表**

2. **广义表的深度**：广义表的深度是指广义表中展开后所含括号的层数
3. **广义表的长度**：广义表的长度是指广义表中所含元素的个数
4. **广义表的特点**：

   - 广义表的元素可以是子表。
   - 广义表可为其他广义表所共享
   - 广义表可以是一个递归的表。

5. **广义表操作**
   - 取表头 GetHead(LS)：取出的表头为非空广义表的第一个元素，它可以是单原子，也可以是一个子表
   - 取表尾 GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表。即表尾一定是一个广义表

```c
/*
// 普通认识
A = () => A 是一个空表，其长度为 0
B = (e) => B 只有一个原子 e,其长度为 1
C = (a, (b,c,d)) => C 的长度为 2，两个元素分别为原子 a 和子表(b,c,d)
D = (A,B,C) => D 的长度为 3,3 个匀速都是广义表
E = (a,E) => 递归表，长度为 2， E 相当于一个无限的广义表

// 广义表的运算实现
GetHead(B) = e
GetTail(B) = ()
GetHead(D) = A
GetTail(D) = (B, C)

*/
```

### 广义表的存储结构

1. 由于广义表中的元素可以有不同的结构，因此难以使用顺序存储表示，通常采用**链式存储**结构。

### 习题

**选择题**

1. B
2. B
3. C
4. A
5. B
6. B
7. C 错 B, 以列存储则 = [7*8+4]\*3
8. C

```c
/**
 * a11为第一个元素，则最后一个元素为a110, a85=a58+11 = a69,a69/2-1 = 34-1 = 33
 */
```

9. 不懂
10. A 错 B

```c
// 由题意可知，矩阵有9行11列，则按行A[8,5] = 10*7+6 = 76， 按列存储76/9= 8 % 4，也就是列存储的[8,5]
```

11. B 错 A，本题为二维数组存一维，存在在以什么开头的数组中，下标最小就要以该数组开头为基准，比如[1..m*n]，以 1 为基准。
12. B

```c
/**
 * 求数组A=[0..4,-1...-3,5..7]的元素个数
 * 0..4, 即01234 有5个
 * -1..-3，即-1，-2，-3, 有3个
 * 5..7，即567，有3个
 * 所以元素个数为5*3*3=45个
 */
```

13. D

```c
/**
 * 广义表A=(a,b,(c,d),(e,(f,g)))，则Head(Tail(Head(Tail(Tail(A)))))的值为
 * 解题方式：从内向外解
 * 1. Tail(A) = (b, (c,d), (e,(f,g)))
 * 2. Tail(Tail(A)) = ((c,d), (e,(f,g)))
 * 3. Head(Tail(Tail(A))) = (c,d)
 * 4. Tail(Head(Tail(Tail(A)))) = (d)
 * 5. Head(Tail(Head(Tail(Tail(A))))) = d
 */
```

14. C,B
15. B 错 C
