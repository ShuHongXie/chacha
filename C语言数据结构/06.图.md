### 图(Graph)

1. 定义：**是由顶点的有穷非空集合和顶点之间边的集合组成**，通常表示为：G(V, E)，其中，G 表示一个图，V(Vertex)是图 G 中顶点的集合，E(Edge) 是图 G 中边的集合。其中**V(G)为图 G 顶点集合，V(G)不能为空，即在图结构中不能没有顶点**，**E(G)为图边的集合，E(G)可以为空集**
2. 分类：分为有向图和无向图。
   - **有向图**：边集 E(G)为有向边的集合
   - **无向图**：边集 E(G)为无向边的集合
3. **弧**：**弧**在有向图中，比如从顶点 x 到顶点 y 的一条有向边，因此<x,y>和<y,x>是不同的两条边，用尖括号括起来，x 是有向边的始点，y 是有向边的终点。<x,y>也称作一条弧，x 为弧尾，y 为弧头。
4. **边**：**边**在无向图中，顶点对(x,y)是无序的，称为顶点 x 到顶点 y 的一条边，这条边无特定方向，所以(x,y)和(y,x)是同一条边
5. **弧和边的关系**：边包括弧，弧不包括边，**有向边也称为弧**。如<A,D> A 是弧尾，D 是弧头，注意不能写成<D,A>，**为区别弧和边，无向图的顶点用一堆圆括号括起来**

### 图的基本术语

**注**：下面用 n 表示图中顶点数目，用 e 表示边的数目：

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_g1.png)

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_g3.png)

4. **子图**：假如有两个图 G=(V,E)和 G1=(V1,E1),如果 V1 ∈ V,E1 ∈ E,则称 G1 为 G 的子图。
5. **无向完全图和有向完全图**：对于无向图，如果任意两个顶点之间都存在边，即存在 **n(n-1)/2** 条边，则称为无向完全图。对于有向图，如果任意两个顶点之间都存在方向互为相反的两条边，即有 **n(n-1)**条弧，则称为有向完全图。
6. **稀疏图和稠密图**：有很少条边或弧(如：e < nlog2^n，e 表示图中边（或弧）的数量，n 表示图中顶点的数量)的图称为稀疏图，反之称为稠密图
7. **权和网**：每条边/弧可以用一个实数来表示特定含义，这个实数就是权，而带权的图通常称为网
8. **邻接点**： 对于无向图 G，如果图的边(v，v')∈E，则称顶点 v 和 v 互为邻接点，即 v 和 v'相邻接。边(v, v)依附于顶点 v 和 v,或者说边(v, v')与顶点 v 和 v 相关联。其实就是**一条边上的两个顶点，这两个顶点就叫邻接点**
9. **度**: 顶点 v 的度是指和 v 相关联的边的数目，记为 TD(v)，**类似于树的结点的度**。
   - 度的计算公式：e(边数) = (图中各顶点的度相加)/2
   - **入度**：以顶点 v 为头的弧的数目，记为 ID(v);
   - **出度**：以顶点 v 为尾的弧的数目，记为 OD(v);
   - **出入度范例**：上图 G1 中的顶点 v1 的入度 ID(v1)=1，出度 OD(v1)=2，度 TD(v1)=ID(v1)+OD(v1)=3。
10. **路径和路径长度**：路径就是一个顶点到另外一个顶点的顶点序列，类似于一个数组，数组里面是路径的每一个点。**路径长度是一条路径上经过的边或弧的数目**
11. **回路或环**:第一个顶点和最后一个顶点相同的路径称为回路或环。
12. **简单路径、简单回路或简单环**:序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。
13. **连通、连通图和连通分量**：在无向图 G 中，如果从顶点 v 到顶点 v'有路径(**也就是不管中间隔了几个顶点，能通过顶点或边走到另外一个顶点**)，则称 v 和 v'是**连通**的。如果对于图中任意两个顶点 v、v'，都是连通的，则称 G 是连通图。上图无向图 G2 就是连通图。
    - **连通分量**：指无向图中极大连通子图。上图 G3 是非连通图，但 G3 有 3 个连通分量
14. **强连通图**：在**有向图**中，若任意两个顶点 Vi 和 Vj，满⾜从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有⾄少⼀条通路，则称此有向图为强连通图。
    - **强连通分量**：有向图中的极大强连通子图称作有向图的强连通分量。
15. **连通图的生成树**: 一个极小连通子图,它含有图中全部顶点，但只有足以构成一棵树的 n-1 条边,这样的连通子图称为连通图的生成树。图 6.5 所示为 G3 中最大连通分量的一棵生成树。
16. **有向树和生成森林**:有一个顶点的入度为 0，其余顶点的入度均为 1 的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。图 6.6 所示为其一例。
    ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_direction.png)

17. [更多参考相关概念参考](https://blog.csdn.net/zsy3757486/category_11712783.html)

### 图的基本总结

1. 图按照有无方向分为有向图和无向图。有向图由顶点和弧构成，无向图由顶点和边构成。弧有弧尾和弧头之分。
2. 图按照边或弧的多少分为稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。
3. 图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。
4. 图上的边或弧上带权则称为网。
5. 图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量。
6. 无向图中连通且 n 个顶点 n-1 条边叫生成树。有向图中一顶点入度为 0 其余顶点入度为 1 的叫有向树。一个有向图由若干棵有向树构成生成森林。

### 图的存储结构

1. 邻接矩阵(顺序存储)=> **无向图**：图的邻接矩阵（Adjacency Matrix)存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。适用于**稠密图**
   - 判断点 Vi 到 Vj 是否存在边或弧，只需查找矩阵中 arc[i][j]是否为 1 即可。
   - 判断顶点的度：这个顶点 Vi 在第 i 行的元素之和，
   - 求顶点 Vi 的所有邻接点就是将矩阵隔中的第 i 行元素扫描一遍
     ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_d1.png)
   - **上图详解：**：矩阵里面的每个值，以行算，对应列。都是代表是否存在两个顶点间的边，比如 a[0][2]=1，代表有 横 V0 到 纵向 V2 的边，a[0][0]=0，代表是不存在 V0 到 V0 的边
2. 邻接矩阵(顺序存储)=> **有向图**
   ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/matrix_2.png)
   - Vi 的入度为第 Vi 列各数之和，出度为第 Vi 行各数之和：口诀**行出列入**
3. 邻接矩阵(顺序存储)=> **带权有向图**
   ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311151659128.png)
   - 带权图，两顶点之间如果不直接相连，则用 ∞ 表示
4. - **邻接矩阵优点**：
   1. 便于判断两顶点之间是否有边
   2. 便于计算各个顶点的度。**对于有向图，第 i 行元素之和就是顶点 i 的出度，第 i 列元素之和就是顶点 i 的入度**
5. - **邻接矩阵缺点**：
   1. 不便于增加和删除顶点，
   2. 不便于统计边的数目，时间复杂度为 O(n^2)
   3. 空间复杂度高
6. 邻接表(链式存储)：由**表头节点表和边表组成**，数组与链表相结合，适用于**稀疏图**，类似于**二叉树的兄弟表示法**，**有向图的邻接表按是按图的出度作为链表项**
   ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_link1.png)
   1. 优点：
      - 便于增加和删除顶点
      - 便于统计边的数目，时间复杂度为 O(n+e)
      - 空间效率高
   2. 缺点：
      - 不便于判断顶点之间是否有边。
      - 不便于计算有向图各个顶点的度
   3. 参考：大话数据结构 P224
7. 十字链表(链式存储)：**即邻接表和逆邻接表结合**，
8. 邻接多重表(链式存储)：
9.

### 图的遍历

1. 深度优先遍历(Deep First Search)：也称深度优先搜索，沿着某一个深度方向遍历，**借助栈结构来实现(递归)，类似于前序遍历**
   - 当用邻接矩阵表示图时，查找每个顶点的邻接点的时间复杂度为 O(n^2)，其中 n 为图中顶点数。
   - 当以邻接表做图的存储结构时，查找邻接点的时间复杂度为 O(e)，其中 e 为图中边数。
   - 当以邻接表做存储结构时，深度优先搜索遍历图的时间复杂度为 O(n+e)。
2. 广度优先遍历(Breadth First Search): 也称广度优先搜索, 由第一个顶点从上到下顺序遍历，**借助队列结构来实现**
   - 当用邻接矩阵存储时，时间复杂度为 O(n^2);
   - 用邻接表存储时，时间复杂度为 O(n+e)。
3. 共同点：**两者时间复杂度相同，且都不唯一**

[图的遍历例子 1](https://mp.weixin.qq.com/s?__biz=MzI4MDYzNzg4Mw==&mid=2247489326&idx=4&sn=db0b4711d43b40ea493a70a2414da599&chksm=ebb42ffadcc3a6ec884cb8eb2524783a92e8ab06ed3242737a9a719115cd2dd078840e964bbb&scene=27)
[图的遍历例子 2](https://zhuanlan.zhihu.com/p/96139190)

#### 图的遍历例题

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310251549430.png)

如上图所示，已知图 G 的邻接表如图所示若以顶点 B 为出发点，请分别写出深度优先搜索和广度优先搜索的项点序列。

```c
/*
以上图的邻接表为例，链表中为当前顶点的下标，根据邻接表构造分析，

=> 深度优先以栈结构为主，查找当前结点的下一个结点，直到没有下一个结点再从头回溯

1. B的链接点为C(2)，C的链接点为E(4)，E的链接点为F(5)，F的链接点为A(0)，至此A没有连接点，往B的链接点回溯，发现A(0)被遍历过，往C的链接点回溯，发现B(1)被遍历过，往D的链接点回溯，发现C(2)，被遍历过，往E的链接点回溯，D(3)没有被遍历过，所以找到D(3)，遍历完成

所以答案为BCEFAD

2. 根据邻接表画图，看下图，有4种可能，深度遍历有向图时需要根据方向来，没方向按序号或者字母序号来

1. BAFCED, 这个比较特殊，因为走到F就停止了，需要向前回溯，而ED没有被访问也没有被BAF连接，所以只能回溯回C，C连接E，E连接D
2. BCEAFD
3. BCEFAD
4. BCEDAF

=> 广度优先以队列结构为主，可对图进行分层，

以B为结点A作为第2层的第一个结点有
B
AC
FE
D

以C为结点A作为第2层的第一个结点有
B
CA
EF
D

所以广度遍历优先为BACFED或BCAEFD

*/
```

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310251637333.png)

### 最小生成树

1. 定义：**构造连通网的最小代价生成树(也就是路径最小的权值)**，（最小生成树的应用：如城市间造路，要求造价最低）,**最小生成树不唯一，但最小生成树的边的权值之和总是唯一的**
2. 构造最小生成树的算法：
   - 普里姆算法(Prim)：**核心是归并点，时间复杂度 O(n^2)，适用于稠密网**，过程可以看大话数据结构 239 页，严蔚敏数据结构 166 页
   - 普里姆算法(Prim)过程：选择一个起点，选择一条权值最小的边，**如果遇到相同的边，则选择最新添加的顶点的边**，且所选的顶点不能形成环
   - 克鲁斯卡尔算法(Kruskal)：**核心是归并边，时间复杂度 O(elog2e)，适用于稀疏网**，过程可以看大话数据结构 244 页

#### 最小生成树例题

1. 寻找某一个顶点，选择这个顶点权值最小的边，以该点和其连接的点为基础，不断寻找最小值的点
2. 重复上面步骤(边不能围合合并)

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310241749005.png)

如题 图所示为一个地区的交通网，顶点表示城市,边表示连接城市间的公路，边上的权值表示修建公路需花费的造价。现在需要选择能够连通每个城市且总造价最省的 5 条公路请画出修建公路的方案,并给出该工程的总造价。

```c
/*
1. 以B为基准点，最小的边为2，连接B和C
2. C和B的所有边种最小的为6，链接B和G
3. BCG最小的边为7，连接B和D
4. BDGC所有便中最小的边为8，但是不能选8，选择8的话会围合，
5. 排除8之后剩下两个都是10，都不围合，所以连接起来，最小生成树成功

总造价为2+6+7+10+10 = 35
*/
```

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310251531402.jpg)

### 最短路径

1. 定义：是指两顶点之间经过的边上权值之和最少的路径，并且我们称**路径上的第一个顶点是源点，最后一个顶点是终点**。**拓扑排序不唯一**
2. 构造最短路径的算法：
   - 迪杰斯特拉算法(Dijkstra)：
     ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401101822625.png)
   - 弗洛伊德算法(Floyd)：主要目标是求解每一对顶点之间的最短路径

### 最小生成树和最短路径的区别

1. 定义：
   - 最小生成树能够保证整个拓扑图的所有路径之和最小，但不能保证任意两点之间是最短路径。
   - 最短路径是从一点出发，到达目的地的路径最小。
2. 总结：
   - 遇到求所有路径之和最小的问题用最小生成树&并查集解决；
   - 遇到求两点间最短路径问题的用最短路，即从一个城市到另一个城市最短的路径问题。
3. 区别：最小生成树构成后所有的点都被连通，而最短路只要到达目的地走的是最短的路径即可，与所有的点连不连通没有关系。

### 拓扑排序

1. 目的：**解决一个工程是否能顺序进行的问题**，检测是否存在环
2. 有向无环图：一个无环的有向图，简称 DAG 图
3. AOV-网：这种用顶点表示活动,用弧表示活动间的优先关系的有向图称为顶点表示活动的网
4. 拓扑排序：将 AOV-网中所有顶点排成一个线性序列，该序列满足:若在 AOV-网中由顶点 Vi 到顶点 Vj 有一条路径，则在该线性序列中的顶点 Vi 必定在顶点 Vj 之前(**前面走过的，不能再走一次，即不能存在回路**)。

#### 拓扑排序例题：**求拓扑排序序列**

1. 寻找入度为 0 的顶点，删除该顶点和以它为弧尾的弧
2. 不断重复上面的步骤

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310241736883.png)

```c
/*
1. 以上图为例：入度为0的顶点为D，删除D及其弧，序列为[D]
2. 去掉D之后，入度为0的顶点为A，删除A及其弧，序列为[DA]
3. 去掉A之后，入度为0的顶点为E,B，删除这两个之一都可以

4. 以E为例子，删除E，序列为[DAE]，
5. 去掉E后，入度为0的顶点为B，删除B及其弧，序列为[DAEB]
6. 去掉B之后，入度为0的顶点为F，删除F及其弧，序列为[DAEBF], 剩下C，最终为[DAEBFC]

4. 以B为例子，删除B，序列为[DAB]，
5. 去掉B后，入度为0的顶点为E，删除E及其弧，序列为[DABE]
6. 去掉E之后，入度为0的顶点为F，删除F及其弧，序列为[DAEBF], 剩下C，最终为[DABEFC]

所以上面图的拓扑排序序列为[DAEBFC]和[DABEFC]
*/
```

### 关键路径 AOE-网

1. 目的：**找一条从源点到汇点的带权路径长度最长的路径,称为关键路径**
2. AOE-网：即以边表示活动的网。AOE-网是一个带权的有向无环图，其中，顶点表示事件，弧表示活动，权表示活动持续的时间。通常，AOE-网可用来估算工程的完成时间.
3. **源点**：由于整个工程只有一开始点和完成，所以在正常情况下，**网中只有一个入度为 0 的点，称为源点**
4. **汇点**：出度为零的点
5. **关键活动**：关键路径上的活动。
6. **事件**：图的顶点
7. **活动**：图的边

### 习题

**选择题**

1. C
2. B
3. B
4. B
5. B，错 C： 8 个顶点的无向图最多有 8\*7/2=28 条边，再添加一个点即构成非连通无向图，故
6. B
7. A
8. B
9. A
10. A
11. D
12. D 错 C
13. C
14. D
15. C 错 B
