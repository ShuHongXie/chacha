### 栈：从 0 开始

1. 定义：栈是限定仅在表尾进行插入或删除操作的线性表。对栈来说，表尾端称为**栈顶**，表头端称为**栈底**，不含元素的空表称为**空栈**。
2. 特点：后进先出(Last In Fisrt Out,LIFO);
3. 操作叫法：栈的插入叫进栈/压栈/入栈，栈的删除操作叫出栈，有的也叫弹栈。

### 栈的链式存储结构及实现

1. 定义：跟线性表的单链表一样，只不过它只能尾进头出

### 递归算法

1. 定义：**若在一个函数、过程或者数据结构定义的内部又直接(或间接)出现定义本身的应用，则称它们是递归的，或者是递归定义的，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出**。在以下三种情况下，常常使用递归的方法。

   1. 定义是递归的。
   2. 数据结构是递归的。
   3. 问题的解法是递归的。

2. 递归函数：**把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称为递归函数**
3. 递归算法的效率分析：
   - 时间复杂度：O(2^n)
   - 空间复杂度：O(n)
4. 递归的优缺点
   - 优点：**递归程序结构清晰，形式简洁**
   - 缺点：**递归程序在执行时需要提供隐式的工作栈来保存调用过程中的参数，局部变量和返回地址，因此递归占用空间多，运行效率低**
5. **递归和迭代的区别**：迭代类似于 for 循环里面的每次递乘，不调用自身(A 调用 B)，递归是每次都调用自身(A 调用 A)

### 队列：从 0 开始

1. 定义：**队列是一种先进先出(First In First Out, FIFO)的线性表**。只允许在表的一端进行插入，而在另一端删除。在队列中，允许插入的一端称为**队尾**，允许删除的的一段称为**队头**
2. 队列顺序存储的不足：1. **每次操作队列元素都得向前移动**，此时时间复杂度为 O(n)。 2. 由于地址连续，很容易因数组越界而导致程序的非法操作错误，称为**假溢出**现象。为解决这种问题，需要使用**循环队列**

### 循环队列

1. 定义：**队列的头尾相连的顺序存储结构称为循环队列**，使用两个指针 rear 和 front 进行标识，front 指向队头元素，rear 指向队尾元素的下一个位置, **两个默认从 0 开始**，在队列满时，数组中还有一个空闲单元。
2. 如何判断循环队列是满的：(rear+1)%QueueSize==front
3. 队空的条件：Q.front = Q.rear
4. 队列长度公式：(rear - front + QueueSize) % QueueSize

### 队列的链式存储结构及实现

1. 定义：跟线性表的单链表一样，只不过它只能尾进头出

### 栈和队列存储方式的优缺点

1. 链式存储：动态分配，不会出现闲置或栈满溢出现象，数据元素个数可以自由扩充
2. 顺序存储：存储空间预先分配,可能会导致空间闲置或栈满溢出现象;数据元素个数不能自由扩充

### 习题

**选择题**

1. C 对

```c
/**
 * 12345入栈
 * 1. 全部一次性进，一次性出，那就是54321
 * 2. 每个依次进后立即出，就是12345
 * 3. 12先进，再出，然后345再进，那就是21543
 * 4. 12先进，然后2出，进3，再出，然后进45，然后出45，再出1，那就是23541
 * 所以C项是不可能出现的，43出的话，下一次出的必定是2，2前面不可能是1
 */
```

2. C 对

```C
/**
 * 1,2，3 所以n=3，若p1=3,即n=3则p3=1，以i为值的话，pi=
 * 12 21 p1=2 p2=1
 */
```

3. D 对
4. A 对
5. A 对
6. D 对
7. A 对
8. B 对

```c
/**
 * 出队顺序是e2，e4，e6, e5, e1，
 * 则入栈的顺序是e1,e2,取出e2,然后入e4,取出e4，然后入e5,e6，取出e6,e5,最后取出e1
 * 则容量最少为3
 */
```

9. A，错：C 初始栈顶指针 top 为 n+1 ，说明元素从数组向量的高端地址进栈，又因为元素
   存储在向量空间 V[1…n] 中，所以进栈时 top 指针先下移变为 n，之后将元素 x 存储在 V[n] 。
10. D 对
11. D 对
12. C 错：D 数组 A[0…m] 中共含有 m+1 个元素，故在求模运算时应除以 m+1。

```C
[0, 1,2,3]
```

13. B 对
14. C 对
15. B 对
