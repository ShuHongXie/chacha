### 栈：从 0 开始

1. 定义：栈是限定仅在表尾进行插入或删除操作的线性表。对栈来说，表尾端称为**栈顶**，表头端称为**栈底**，不含元素的空表称为**空栈**。
2. 特点：后进先出(Last In Fisrt Out,LIFO);
3. 操作叫法：栈的插入叫进栈/压栈/入栈，栈的删除操作叫出栈，有的也叫弹栈。

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202312281626113.png)

### 顺序栈的结构

1.  ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202402051949441.png)

```C

typedef struct {
   SElemType *base; //栈底指针
   SElemType *top; //栈顶指针
   int stacksize; //栈可用的最大容量
} SqStack;

```

2. base 为栈底指针，始终指向栈底，如果为 NULL 则表明栈结构不存在
3. top 为栈顶指针，其初值指向栈顶。每插一个新元素 top 就增加 1，反之减 1
4. 顺序栈操作时的注意点
   - 入栈时要判断栈是否已满，栈未满时将新元素入栈，栈顶指针+1
   - 出栈时要判断栈是否为空，栈未空时，栈顶元素出栈，切栈顶指针-1
5. 顺序栈容易受到最大空间容量限制

### 栈的链式存储结构及实现

1. 定义：跟线性表的单链表一样，只不过它只能尾进头出
2. 链栈操作时的注意点：
   - 入栈时不需要判断是否满，只需要为入栈元素动态分配一个结点空间
   - 出栈，取栈顶元素需要判断是否为空

### 递归算法

1. 定义：**若在一个函数、过程或者数据结构定义的内部又直接(或间接)出现定义本身的应用，则称它们是递归的，或者是递归定义的，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出**。在以下三种情况下，常常使用递归的方法。

   1. 定义是递归的。
   2. 数据结构是递归的。
   3. 问题的解法是递归的。

2. 递归函数：**把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称为递归函数**
3. 递归算法的效率分析：
   - 时间复杂度：O(2^n)
   - 空间复杂度：O(n)
4. 递归的优缺点
   - 优点：**递归程序结构清晰，形式简洁**
   - 缺点：**递归程序在执行时需要提供隐式的工作栈来保存调用过程中的参数，局部变量和返回地址，因此递归占用空间多，运行效率低**
5. **递归和迭代的区别**：迭代类似于 for 循环里面的每次递乘，不调用自身(A 调用 B)，递归是每次都调用自身(A 调用 A)

### 队列：从 0 开始

1. 定义：**队列是一种先进先出(First In First Out, FIFO)的线性表**。只允许在表的一端进行插入，而在另一端删除。在队列中，允许插入的一端称为**队尾**，允许删除的的一段称为**队头**
2. 队列顺序存储的不足：1. **每次操作队列元素都得向前移动**，此时时间复杂度为 O(n)。 2. 由于地址连续，很容易因数组越界而导致程序的非法操作错误，称为**假溢出**现象。为解决这种问题，需要使用**循环队列**
3. **假溢出**：因数组越界而导致程序的非法错误。

### 循环队列

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202312281649712.png)

1. 定义：**队列的头尾相连的顺序存储结构称为循环队列**，使用两个指针 rear 和 front 进行标识，front 指向队头元素，rear 指向队尾元素的下一个位置, **两个默认从 0 开始**，在队列满时，数组中还有一个空闲单元。
2. 如何判断循环队列是满的：(rear+1)%QueueSize==front
3. 队空的条件：Q.front == Q.rear
4. 队列长度公式：(rear - front + QueueSize) % QueueSize
5. 循环队列操作时注意事项：
   - 入队要判断队满
   - 出队，取队头要判断队空

### 队列的链式存储结构及实现

1. 定义：跟线性表的单链表一样，只不过它只能尾进头出
2. 链队列入队时不需要判断队列是否满
3. 链队列操作时注意事项：
   - 链队列出队时需要判断是否为空
   - 出队，取队头要判断队空

### 栈和队列存储方式的优缺点

1. 链式存储：动态分配，不会出现闲置或栈满溢出现象，数据元素个数可以自由扩充
2. 顺序存储：存储空间预先分配,可能会导致空间闲置或栈满溢出现象;数据元素个数不能自由扩充
