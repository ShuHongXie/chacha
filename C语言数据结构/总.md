### 宏定义与常量的区别

1.  宏定义是一种预处理指令，用于在编译之前替换代码中的文本。宏定义使用 define 关键字，后面跟着宏的名称和宏的替换文本，例如 #define Pi3.14，就表示一个宏定义，此时的 Pi 是一个符号常量。
2.  - 1.存储方式:常量是在编译时存储在内存中的，而宏是在预处理阶段直接替换掉相应的代码，没有存储在内存中。
    - 2.类型:常量具有具体的类型(如 int,float 等)，而宏没有具体的类型。
3.  安全性:常量比宏更安全，因为编译器可以对常量的值进行检查，例如类型不匹配、数值溢出等。而宏只是简单的文本替换，编译器无法对宏进行这种检查。
4.  效率:由于宏是预处理器进行文本替换，不占用运行时内存，所以可能比使用常量更高效。然而，这也取决于具体的代码和编译器优化。

### 基本概念和术语

1. 数据：数据是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号总称。(比如：c 语言程序中定义的整数实数，字符串，多媒体处理的图形 img,png 等)
2. 数据元素：数据元素是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。(比如：一名学生记录)
3. 数据项：数据项是组成数据元素的，有独立含义的，不可分割的最小单位。(比如：学生记录中的学号，姓名，性别)
4. 数据对象：数据对象是性质相同的数据元素的集合，是数据的一个子集。（比如：多个学生记录的集合）

从小到大排列
数据>数据对象>数据元素>数据项

### 数据结构

**数据结构是相互之间存在一种或多种特定关系的数据元素的集合**。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

1. 数据结构包括**逻辑结构**和**存储结构**
2. 数据的**逻辑结构**是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。

   - 数据逻辑结构的两个要素：1. 数据元素。2. 关系：指数据元素之间的逻辑关系。
   - 数据元素之间关系的不同，通常有四种基本结构：**1. 集合结构(单个) 2.线性结构(一对一) 3.树结构(一对多) 4.图结构或网状结构(多对多)**
   - 数据逻辑结构的分类： 1. 线性结构 2. 非线性结构(集合，树，图)

     ![](https://www.xiesmallxie.cn/20221108173935.png)

3. **数据对象在计算机中的存储表示称为数据的存储结构**，也叫**物理结构**
   分类：[参考地址](https://blog.csdn.net/weixin_43847283/article/details/130352682)
   1. **顺序存储结构**：把数据放在地址连续的存储单元里面
   2. **链式存储结构**：把数据元素存放在任意的存储单元，这组存储单元可连续，也可以不连续。
   3. 索引存储结构
   4. 散列存储结构

### 数据类型和抽象数据类型(可以理解为 C 语言的 struct 对象)

1. **数据类型**：一个值的集合以及定义在这个值集上的一组操作的总称。(比如：)

2. **数据抽象类型是指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分:数据对象、数据对象上关系的集合，以及对数据对象的基本操作的集合。**
   - 数据对象
   - 数据对象上关系的集合
   - 对数据对象的基本操作

### 算法

1. **作用：算法是为了解决某类问题而规定的一个有限长的操作序列**

一个算法必须满足以下五个重要特性：

1. **有穷性**，一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成
2. **确定性**，每种情况下执行的操作，在算法中都有确切规定，不会产生二义性，使算法的执行者或阅读者都能明白其含义以及如何执行
3. **可行性**，算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现
4. **输入**，一个算法有零个或多个输入，当用函数描述算法时，输入往往通过形参表示，在它们被调用时，从主调函数获得输入值。
5. **输出**，一个算法有一个或多个输出

**算法优劣的基本标准**

1. **正确性**：在合理的数据输入下，能够在有限的运行时间内得到正确的结果
2. **可读性**：好的算法应该易于人们理解和相互交流
3. **健壮性**：当输人的数据非法时，好的算法能适当做出正确反映或进行相应处理，而不会产生一些莫名其妙的输出效果
4. **高效性**：好的效果执行效率高

**算法的两个主要方面**

1. 算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，以考察算法的时间和空间效率。一般情况下，鉴于运算空间较为充足，故**将算法的时间复杂度作为分析的重点**。

### 算法的时间复杂度

1. 问题规模：指算法求解问题输入量的多少，用整数 n 表示。
2. 语句频度：一条语句重复执行的次数。
3. 定义：指执行算法所需要的计算工作量，定性描述该算法的运行时间。
   时间复杂度对比：O(1) < O(log2 ^n) < O(n) < O(nlog2 ^n) < O(n^2) < O(n^3); [log2 ^n(以 2 为底，n 的对数)]
4. 评估标准：一般在没有特殊说明的情况下，都是指最坏时间复杂度。

**重要含义：算法的时间复杂度不仅与问题的规模有关，还取决于待处理数据的初始状态**

### 算法的空间复杂度

定义：指一个算法在运行过程中临时占用存储空间大小的量度

### 线性表(数组)

**定义**：n(n>=0)个数据特性相同的元素构成的有限序列称为线性表,n 代表线性表的长度，n=0 时为空表, 线性表存储的地址是连续的。

**非空线性表的特点:**

1. 存在唯一一个被称作"第一个"的数据元素
2. 存在唯一一个被称作"最后一个"的数据元素
3. 除第一个之外，结构中的每个数据元素均只有一个前驱
4. 除最后一个之外，数据中的每个元素均有一个后继

### 线性表的顺序表示和实现

1. 线性表的顺序存储结构：**用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表为顺序表**
2. **顺序表是种随机存取的存储结构**
3. 缺点：**插入和删除时需要移动大量元素，会耗费较多时间**

**操作费时**

1. 取值：O(1)
2. 插入,查找,删除：O(n)
3. 平均查找长度(n+1)/2

## 线性表的链式表示和实现

### 单链表表示

1. 特点：**用一组任意的存储单元存储线性表的数据元素**
2. 定义：线性表的链表除了存储其自身元素，还需要存储一个指示其直接后继的信息，这两部分信息组成数据元素，称为**结点**，它包括两个域, **数据域**和**指针域**，指针域中存储的信息称作**指针**或**链**，n 个结点链接称为一个链表，即为线性表的链式存储结构。**由于此链表中的每个节点只包含一个指针域，又称为线性链表或单链表。**
   - 线性链表/单链表：链表中的每个结点中只包含一个指针域。
   - 首元结点：链表中存储第一个数据元素 a1 的结点。
   - 头结点：头结点是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。例如，当数据元素为整数型时，头结点的数据域中可存放该线性表的长度。
   - **头结点的作用：1. 便于首元结点的处理(若单链表不带头结点，则首元结点无前驱结点，在其前插入结点和删除该结点操作复杂些。)。 2. 便于空表和非空表的统一处理(即无论链表是否为空，头指针都是指向头节点的非空指针)**
   - 头指针：头指针是指向链表中第一个结点的指针。若链表设有头结点，则头指针所指结点为线性表的头结点;若链表不设头结点，则头指针所指结点为该线性表的首元结点
3. 前插法：定义头结点后，每一次都在首元节点处插入, O(n)
4. 后插法：定义头结点后，每次都在最后一个结点后插入, O(n)
5. 单链表结构与顺序存储结构的优缺点：
   - 如果需要频繁查找，很少进行插入和删除时，适合采用顺序存储结构
   - 当线性表中元素个数变化较大或根本不知道多大时最好用单链表结构

**操作费时**

1. 取值：O(n)
2. 查找：O(n)
3. 插入：O(n)
4. 删除：O(n)

**一些判断 L 为头指针**

1. 不设头结点时，如何判断空表：L==NULL
2. 设头结点时，如何判断空表：L->next == NULL

# 简述在单循环链表上尾指针取代头指针的作用？

在用头指针表示的单循环链表中，找开始结点 a1 的时间是 O(1)，然而要找终端结点 an 则需要从头指针开始遍历整个链表，其时间是 O(n)，在很多实际问题中，表的操作常常是在表尾进行的，此时头指针表示的单循环链表就显得不够方便，如果改用尾指针来表示单循环链表，则查找开始结点 a1 和终端结点 an 都很方便查找时间都是 O(1)

### 循环链表

1. 特点：**表中最后一个结点的指针域指向头结点，整个链表形成一个环**
2. 和单链表的区别：当链表遍历时，判别当前指针 p 是否指向表尾结点的终止条件不同。在单链表中，判别条件为 p!=NULL 或 p->next!=NULL，而循环链表的判别条件为 p!=L 或 p->next!=L

### 双向链表

1. 特点：存在两个指针域，一个指向直接后继，一个指向直接前驱
2. 双向链表的好处：单链表中查找直接后继结点的执行时间为 O(1), 而查找前驱的执行时间为 0(n),双向链表可以**克服单链表的前驱查询时间问题**。

### 单链表，循环链表和双向链表的比较

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310191624678.png)

### 顺序表和链表的比较 优劣性

**空间性能比较**

什么是存储密度？存储密度 = 数据元素本身占用的存储量/结点结构占用的存储量

存储空间分配：链表 > 线性表
存储密度：顺序表存储密度为 1，链表的存储密度小于 1(因为链表结点结构里面还有指针域也占用了内存)

**时间性能的比较**

存取元素的效率：如果线性表的操作只是和元素位置紧密相关的，比较适合采用顺序表
插入和删除操作的效率：如果线性表的操作经常做做插入或删除时，比较适合采用链表

### 线性表的合并

ab 两个线性表合并：时间复杂度 O(mn)，因为还要判断 b 中的每个元素在 a 中是否已经存在

### 有序表的合并

有序表：若线性表中的数据元素相互之间可以比较，并且数据元素在线性表中依值非(递增/递减)有序排列，则该线性表为有序表。

- 顺序有序表：时间复杂度 O(m+n)，空间复杂度 O(m+n)
- 链式有序表：时间复杂度 O(m+n)，空间复杂度 O(1)

### 栈：从 0 开始

1. 定义：栈是限定仅在表尾进行插入或删除操作的线性表。对栈来说，表尾端称为**栈顶**，表头端称为**栈底**，不含元素的空表称为**空栈**。
2. 特点：后进先出(Last In Fisrt Out,LIFO);
3. 操作叫法：栈的插入叫进栈/压栈/入栈，栈的删除操作叫出栈，有的也叫弹栈。

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202312281626113.png)

### 顺序栈的结构

1.  ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202402051949441.png)

```C

typedef struct {
   SElemType *base; //栈底指针
   SElemType *top; //栈顶指针
   int stacksize; //栈可用的最大容量
} SqStack;

```

2. base 为栈底指针，始终指向栈底，如果为 NULL 则表明栈结构不存在
3. top 为栈顶指针，其初值指向栈顶。每插一个新元素 top 就增加 1，反之减 1
4. 顺序栈操作时的注意点
   - 入栈时要判断栈是否已满，栈未满时将新元素入栈，栈顶指针+1
   - 出栈时要判断栈是否为空，栈未空时，栈顶元素出栈，切栈顶指针-1
5. 顺序栈容易受到最大空间容量限制

### 栈的链式存储结构及实现

1. 定义：跟线性表的单链表一样，只不过它只能尾进头出
2. 链栈操作时的注意点：
   - 入栈时不需要判断是否满，只需要为入栈元素动态分配一个结点空间
   - 出栈，取栈顶元素需要判断是否为空

### 递归算法

1. 定义：**若在一个函数、过程或者数据结构定义的内部又直接(或间接)出现定义本身的应用，则称它们是递归的，或者是递归定义的，每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出**。在以下三种情况下，常常使用递归的方法。

   1. 定义是递归的。
   2. 数据结构是递归的。
   3. 问题的解法是递归的。

2. 递归函数：**把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称为递归函数**
3. 递归算法的效率分析：
   - 时间复杂度：O(2^n)
   - 空间复杂度：O(n)
4. 递归的优缺点
   - 优点：**递归程序结构清晰，形式简洁**
   - 缺点：**递归程序在执行时需要提供隐式的工作栈来保存调用过程中的参数，局部变量和返回地址，因此递归占用空间多，运行效率低**
5. **递归和迭代的区别**：迭代类似于 for 循环里面的每次递乘，不调用自身(A 调用 B)，递归是每次都调用自身(A 调用 A)

### 队列：从 0 开始

1. 定义：**队列是一种先进先出(First In First Out, FIFO)的线性表**。只允许在表的一端进行插入，而在另一端删除。在队列中，允许插入的一端称为**队尾**，允许删除的的一段称为**队头**
2. 队列顺序存储的不足：1. **每次操作队列元素都得向前移动**，此时时间复杂度为 O(n)。 2. 由于地址连续，很容易因数组越界而导致程序的非法操作错误，称为**假溢出**现象。为解决这种问题，需要使用**循环队列**
3. **假溢出**：因数组越界而导致程序的非法错误。

### 循环队列

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202312281649712.png)

1. 定义：**队列的头尾相连的顺序存储结构称为循环队列**，使用两个指针 rear 和 front 进行标识，front 指向队头元素，rear 指向队尾元素的下一个位置, **两个默认从 0 开始**，在队列满时，数组中还有一个空闲单元。
2. 如何判断循环队列是满的：(rear+1)%QueueSize==front
3. 队空的条件：Q.front == Q.rear
4. 队列长度公式：(rear - front + QueueSize) % QueueSize
5. 循环队列操作时注意事项：
   - 入队要判断队满
   - 出队，取队头要判断队空

### 队列的链式存储结构及实现

1. 定义：跟线性表的单链表一样，只不过它只能尾进头出
2. 链队列入队时不需要判断队列是否满
3. 链队列操作时注意事项：
   - 链队列出队时需要判断是否为空
   - 出队，取队头要判断队空

### 栈和队列存储方式的优缺点

1. 链式存储：动态分配，不会出现闲置或栈满溢出现象，数据元素个数可以自由扩充
2. 顺序存储：存储空间预先分配,可能会导致空间闲置或栈满溢出现象;数据元素个数不能自由扩充

### 串

1. 定义：**串(或字符串)是由零个或多个字符组成的有限序列**。一般记为 s="a1a2a3...an"，**串中字符的数目 n 称为串的长度**，零个字符的串称为**空串**，长度为 0。
2. 特性：串中任意个连续字符组成的子序列成为该串的**子串，串是自身的子串**，包含子串的串相应地成为**主串**，通常称字符在序列中的序号成为该字符在串中的**位置**。
3. 空格串：由一个或多个空格组成的串" "称为**空格串**，空格串的长度为空格字符的个数。
4. 如何判断串是否相等？：**两个串长度相等，并且各个对应位置的字符都相等**，所有的空串是相等的。
5. 串的链式存储和顺序存储：对于串来说，顺序存储比链式存储灵活，性能也比链式存储好。
6. 前缀：字符串的子串中从原串最前面开始的子串，如 abcdef 的前缀有：a,ab,abc,abcd,abcde
7. 后缀：字符串的子串中在原串结尾处结尾的子串，如 abcdef 的后缀有：f,ef,def,cdef,bcdef
8. 子串：串中任意个连续字符组成的子序列称为该串的子串(**包含空串和自身**)。如"abcdef"的子串有：""、"a"、"ab"、"abc"、"abcd","abcde"和"abcdef"等
9. **求子串个数**：n(n+1)/2 + 1
10. 真子串：指不包含自身的所有子串。

### 串的顺序存储

1.

```c
/*
#define MAXLEN 255
typedef struc {
   char ch[MAXLEN+1];
   int length;
}

*/
```

2. 特点：和数组一样

### 串的链式存储

1. 一个结点可以存储放多个字符

```c
/*

typedef struct Chunk {
   char ch[80]; // 一个结点存放80个字符
   strcut Chunk *next;
}
type struct {
   Chunk *head,*tail;
   int length;
} LString;

*/
```

2. 特点：和数组一样

### 串的链式存储

### 串的模式匹配算法

子串的定位运算通常称为串的**模式匹配**或**串匹配**

1. **BF 算法(暴力算法)，也叫朴素的模式匹配算法**
   过程：以 0 为起点

   1. 指定一个主串 S 和匹配模式子串 T，初始化 pos 为主串 S 的开始索引，初始化 j=1 为子串 T 的开始索引
   2. pos 和 j 开始比较，如果相同则索引相加，如果不相同，pos = pos - j + 1, j 重置为 0
   3. 参考 string1.c 文件的 getIndex1 函数

时间复杂度：最好情况 O(n) 平均 O(m+n) 最坏情况 O(m\*n)

2. **KMP 算法，也叫改进的模式匹配算法\***：参考：https://blog.csdn.net/Marco458748194811/article/details/121799921
3. 两者比较：BF 算法实现简单，但存在回溯，效率低，时间复杂度为 O(m\*n)。KMP 算法对 BF 算法进行改进，消除回溯，提高了效率，时间复杂度为 O(m + n)。
4. [求 KMP 算法计算 next 数组和 nextval 数组](https://blog.csdn.net/qq_50595984/article/details/120424647)

```c
/**
   next数组的求解方法：
   根据当前next求前面的最长公共前后缀，如果有公共前后缀，就根据前缀的位置+1，没有公共前后缀则为1

   以abcabcacb为例： 011123451
   1. 开始ab的next数组默认设为01
   2. 走到c，c向前追溯，发现没有找到公共前后缀，则置为1，此时，next数组为011
   3. 走到a，a向前追溯，发现没有找到公共前后缀，则置为1，此时next数组为0111
   3. 走到b，b向前追溯，发现找到最长公共前后缀ab，则在前缀b的基础上加1，此时next数组为01112
   ...

   nextval求解方法：
 */
```

### 数组

1. 定义：由类型相同的数据元素构成的有序集合，每个元素称为数组元素
2. 数组的存储方式：**按行存储**，**按列存储**
3. 数组的寻址公式:
   - L => 存储单元 n =>数组长度 j => 二维数组 LOC 的第二个参数
   - A[m,n] => m 代表行，n 代表列
   - LOC(i,j) = LOC(0,0) + (n\*i+j)
   - 其中 LOC(i,j)是 aij 的存储位置；LOC(0,0)是 a00 的存储位置，也称为基地址或基址
4. [寻址公式(对上面的补充):](https://www.cnblogs.com/gmengshuai/p/13976038.html)
   - **设数组为 A[m][n]（m 行 n 列），要求的数组为 A[i][j]（i 行 j 列），L 为存储单元所占空间。则有下列公式**
   - 行优先：LOC(i,j) = LOC(0,0) + [i * n + j] \*L;
   - 列优先：LOC(i,j) = LOC(0,0) + [j * m + i] \*L;
5. 一些需要辩解清的点：

```c


/*
比如以一个二维数组A[0..m-1, 0..n-1]，a00代表第一行第一列
则任意位置aij的位置LOC(i, j) = LOC(0,0)+(n*i+j)

比如以一个二维数组A[1..m, 1..n]，基地址a11代表第一行第一列,
则任意位置aij的位置LOC(i, j) = LOC(0,0)+((n-1)*i+j)

*/
```

### 特殊矩阵的压缩存储

[总体参考](https://blog.csdn.net/Yaoyao2024/article/details/129959477)

0. **矩阵 i,j 为行列，以 1 开始，k 为存储位置，从 0 开始**
1. 对称矩阵，n 阶矩阵 A 满足 aij=aji，则成为**n 阶对称矩阵**
   - [参考](http://c.biancheng.net/view/3369.html)
2. 三角矩阵
   - 上三角矩阵：上三角矩阵是一种方阵，其中所有位于主对角线以下的元素都是零，**按列存储**
     1. 压缩原理：
     2. 压缩方程：
        - 按列存储：K = j(j-1)/2+i-1 (i <=j)
          -  按行存储：K = [(i-1)(2n-i+2)/2]+ (j-i) (i <= j)
        - 下三角元素所在位置 K = n(n+1)/2 (i<j)
        - ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311071746306.png)
        - 以上面的矩阵为例子，第二行(i=2), 第二列(j=2), 按列存储，k=2/2 + 1 = 2，所以第二行第二列存储着数组的中下标为 2 的元素
   - 下三角矩阵是一种方阵，其中所有位于主对角线以上的元素都是零，**按行存储**
     1. 压缩原理：
     2. 压缩方程：
        - 按行存储： k = i(i-1)/2+j-1 (i >=j)
          -  按列存储：K = [(j-1)(2n-j+2)/2]+ (i-j) (i > = j)
        - 上三角元素所在位置：k = n(n+1)/2 (i>j)
        - ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311071746681.png)
        - **原理**：类似于 1+2+3+...+10 = (10\*11)/2，令 10=i-1，则有(i-1)(i-1+1)/2 = (i-1)i/2，然后下三角的第 i 行总共有 j 个数据，矩阵是从 1 开始，而所存数组是从 0 开始，因此要在原来基础上减 1，所以为(i-1)i/2 + j - 1
3. 对角矩阵
4. 稀疏矩阵：从直观上来讲，当非零元素低于总元素的 30%时，这样的矩阵称为稀疏矩阵
5. 稀疏矩阵-三元组法：**每个非零元素在存储自身的值的基础上再加两个域**
   - 行域：存储这个非零元素在原来的的矩阵中所占的行号
   - 列域：存储这个非零元素在原来的矩阵中所占的列号
     ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311141750479.png)
   - 三元组表转换：按行优先
     ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311141755192.png)
6. 稀疏矩阵-十字链表法：

### 广义表

1. 定义：广义表是线性表的推广，一般基座 LS=(a1,a2,...an),其中 n 是其长度(1<=i<=n)，**ai 可以是单个元素，也可以是广义表，分表称为广义表的原子和子表**。习惯上用大写字母表表示广义表，用小写字母表示原子。

   - 当 ai 为单个元素时，称作广义表的**原子**
   - 当 ai 为广义表时，称作广义表的**子表**

2. **广义表的深度**：广义表的深度是指广义表中展开后所含括号的层数
3. **广义表的长度**：广义表的长度是指广义表中所含元素的个数
4. **广义表的特点**：

   - 广义表的元素可以是子表。
   - 广义表可为其他广义表所共享
   - 广义表可以是一个递归的表。

5. **广义表操作**
   - 取表头 GetHead(LS)：取出的表头为非空广义表的第一个元素，它可以是单原子，也可以是一个子表
   - 取表尾 GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表。即表尾一定是一个广义表
6. [广义表的存储结构](https://blog.csdn.net/weixin_43118073/article/details/102764276)

```c
/*
// 普通认识
A = () => A 是一个空表，其长度为 0
B = (e) => B 只有一个原子 e,其长度为 1
C = (a, (b,c,d)) => C 的长度为 2，两个元素分别为原子 a 和子表(b,c,d)
D = (A,B,C) => D 的长度为 3,3 个匀速都是广义表
E = (a,E) => 递归表，长度为 2， E 相当于一个无限的广义表

// 广义表的运算实现
GetHead(B) = e
GetTail(B) = ()
GetTail(C) = ((b,c,d))
GetHead(D) = A
GetTail(D) = (B, C)

*/
```

### 广义表的存储结构

1. 由于广义表中的元素可以有不同的结构，因此难以使用顺序存储表示，通常采用**链式存储**结构。
2. 一个表结点可由 3 个域组成:**标志域**、**指示表头的指针域**和指示**表尾的指针域**。而原子结点只需两个域: **标志域**和**值域**。如图 4.15 所示，其中 tag 是标志域，值为 1 时表明结点是子表，值为 0 时表明结点是原子。

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202312311715240.png)

### 树

1. 定义：树的 n(n>=0)个结点的有限集，它或为空树或为非空树
   **非空树的特点**
   - 有且仅有一个称之为根的结点
   - 除根结点以外的其余结点可分为 m(m>0)个不相交的有限集 T1，T2，...Tm，其中每个集合本身又是一棵树，并且称为根的子树(SubTree)。
   - n>0 时根结点是唯一的
   - m>0 时，子树的个数没有限制，但他们**一定互不相交**

### **树的基本术语**

![树](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/tree.png#pic_center)

1. **结点**:树中的一个独立单元。包含一个数据元素及若干指向其子树的分支，如图 5.1(b)中的 A、B、C、D 等。
2. **结点的度**:结点拥有的子树数称为结点的度。例如，A 的度为 3,C 的度为 1,F 的度为 0。
3. **树的度**:树的度是树内各结点度的最大值。图 5.1 (b）所示的树的度为 3。
4. **叶子**:度为 0 的结点称为叶子或终端结点。结点 K、L、F、G、M、I、J 都是树的叶子。
5. **非终端结点**:度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。
6. **双亲和孩子**:结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B 的双亲为 A，B 的孩子有 E 和 F。
7. **兄弟**:同一个双亲的孩子之间互称兄弟。例如，H、I 和 J 互为兄弟。
8. **祖先**:从根到该结点所经分支上的所有结点。例如，M 的祖先为 A、D 和 H。
9. **子孙**:以某结点为根的子树中的任一结点都称为该结点的子孙。如 B 的子孙为 E、K、L 和 F。
10. **层次**:结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加 1。
11. **堂兄弟**:双亲在同一层的结点互为堂兄弟。例如，结点 G 与 E、F、H、I、J 互为堂兄弟。
12. **树的深度**:树中结点的最大层次称为树的深度或高度。图 5.1 ( b)所示的树的深度为 4。
13. **有序树和无序树**:如果将树中结点的各子树看成从左至右是有次序的（即不能互换),则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
14. **森林**:是 m (m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此,也可以用森林和树相互递归的定义来描述树。
15. **树的高度、深度、层的区别(严蔚敏版)**：深度，高度，层次都从 1 开始，都一样

### 树的存储结构

1. 双亲表示法：每个结点除了数据域 data 之外，还附设一个 parent 域用以指示其双亲结点的位置。

**好处**：很容易求结点的双亲，
**缺点**：但是求结点的孩子时需要遍历整个结构

```c
typedef struct BitNode
{
  int data;
  int parent;  // parent为父结点的index下标, 根节点的parent为-1
  struct BitNode *lchild, *rchild;
} BitNode;
```

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401272223656.png)

2. 孩子表示法：孩子表示法存储普通树采用的是 "顺序表+链表" 的组合结构，其存储过程是：从树的根节点开始，使用顺序表依次存储树中各个节点。需要注意，与双亲表示法不同的是，孩子表示法会给各个节点配备一个链表，用于存储各节点的孩子节点位于顺序表中的位置。如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。

**好处**：**便于那些涉及孩子的操作的实现**，比如查找某个结点的某个孩子，或者找某个结点的兄弟

```c
typedef struct BitNode {
   ElemType data;
   CLNode *child; // 孩子节点链表，以上面的二叉树为例 A.CLNode => B -> C -> D，B.CLNode => E -> F， F.CLNode -> null
}
```

[孩子表示法](https://blog.csdn.net/weixin_45895026/article/details/104067660)

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401272223994.png)

3. 孩子兄弟法：又叫二叉树表示法、二叉链表表示法，即以二叉链表作为树的存储结构。链表中节点的两个链域分别指向该节点的第一个孩子节点 firstChild 和下一个兄弟节点 nextSibling

**好处**：和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树算法实现对树的操作

```c
typedef struct BitNode {
   ElemType data;
   CBNode *firstChild, *nextSibling;
}
```

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401272227614.png)
![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401272227837.png)

### 二叉树

1. 定义：树的 n(n>=0)个结点所构成的集合，它或为空树(n=0)或为非空树
   **非空二叉树的特点**
   - 有且仅有一个称之为根的结点
   - 除根结点以外的其余点分为两个不交的子集 T1 和 T2，分别称为 T 的左子树和右子树，且 T1 和 T2 本身又都是二叉树。
   - 二叉树每个结点至多只有两棵子树(即二树中不存在度大于 2 的结点)
   - 二叉树的子树有左右之分，其次序不能任意颠倒
2. 由第一点可知：二叉树有 5 种形态：1. 空二叉树 2. 仅有根节点的二叉树 3. 右子树为空的二叉树 4.左子树为空的二叉树 5. 左右子树均非空的二叉树
3. **二叉树的性质**

   1. 在二叉树的第 i 层上至多有 2^(i-1)个结点(i>=1)
   2. 深度为 K 的二叉树至多有(2^k)-1 个结点
   3. 对任何一棵二叉树 T，如果其终端结点数为 N0，度为 2 的结点数为 N2，则 N0 = N2+1

   - ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/tree_type.png)

   4. 斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。这两者统称为斜树。
   5. **满二叉树**：深度为 K 且含有(2^k)-1 个结点的二叉树
   6. **完全二叉树(从上到下次顺序相同，不存在空位)**：深度为 k 的有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应时，称之为完全二叉树。

      - 完全二叉树的叶子结点只可能在层次最大的两层上出现
      - 对任一结点，若其右分支下的子孙的最大层次为 ，则其左分支下的子孙的最大层次必为 1 或 1+1。图 5.6 中(c)和(d)不是完全二叉树。
      - 具有 n 个结点的完全二叉树的深度为(log2^n)+1,(底数 2，指数 n，log 以 2 为底 n 的对数)，
      - 如果对一颗有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i 有
        1. 如果 i=1，则结点 i 是二叉树的根，无双亲，如果 i>1，其双亲是结点 i/2
        2. 如果 2i>n, 则结点无左孩子；否则其左孩子是结点 2i
        3. 如果 2i+1>n,则结点 i 无右孩子；否则其右孩子是结点 2i+1

### 二叉树的存储结构

1. 顺序存储：顺序存储仅适用于完全二叉树。因为，按树的结构可以会存在空子树，空子树的每个结点都会占用存储空间，会造成存储空间的浪费
2. 链式存储：对于非完全二叉树比较适合

```c
typedef struct BitNode
{
  int data;
  struct BitNode *lchild, *rchild;
} BitNode;
```

3. **二叉树的链式存储和遍历方式**

三种遍历方式：可以记序为根，即先根遍历，中根遍历，后根遍历

1. 先序遍历(根左右)
2. 中序遍历(左根右)
3. 后序遍历(左右根)
4. 层序遍历(从上到下，从左到右)
5. **只有知道树的先序遍历和中序遍历，或者树的中序遍历和后序遍历，才能确定一颗二叉树**

[参考](https://blog.csdn.net/weixin_64916311/article/details/130157918)

### 线索二叉树

1. 定义：将传统的二叉链表的空指针指向其前驱或者后继的指针，这样就可以像遍历单链表那样方便地遍历二叉树，以这种结点构成的二叉列表称为线索链表。加上线索的二叉树称为线索二叉树。[参考链接](http://www.360doc.com/content/23/0717/08/1088837338_1088837338.shtml)
2. 概念：
   - 对于一个有 n 个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以共有**2n 个指针域**
   - **n 个结点的二叉树有 n-1 条分支，存在 2n-(n-1)= n+1 个空指针域**
3. 线索：线索二叉树中指向结点前驱和后继的指针
4. 线索化：对二叉树以某种次序遍历，使其变为线索二叉树的过程称做是线索化
5. **出现的问题？**：无法知道某一节点的 lchild 是指向做孩子还是前驱，rchild 是指向右孩子还是后继，对此需要设置一个区分标志，即设置两个标志域**ltag**和**rtag**，只存放 0 或 1 数字的布尔型变量
   - ltag 为 0 时指向该结点的左孩子，为 1 指向前驱
   - rtag 为 0 时指向该结点的右孩子，为 1 指向后驱
6. **如何作用**：
   1. 若结点的左孩子不为空，LChild 指针域仍指向其左孩子，否则，LChild 指针域指向遍历过程序列的前驱结点。
   2. 若结点的右孩子不为空，RChild 指针域仍指向其右孩子，否则，RChild 指针域指向遍历过程序列的后继结点。
   3. 对于 Ltag 和 Rtag 的标志域的定义：
      Ltag = 0 时，LChild 域指向结点的左孩子。
      Ltag=1 时， LChild 域指向结点的遍历前驱。
      Rtag=0 时，RChild 域指向结点的右孩子。
      Rtag=1 时，RChild 域指向结点的遍历后继。

```c
// 线索二叉树结构
typedef struct Node
{
   TypeData data;
   int Ltag,Rtag;
   struct Node*LChild;
   Struct Node*RChild;
} BiTree, *BiThrTree;
```

**好处**：加快查找结点的前驱或后继的速度

## 森林，树与二叉树的转换步骤

https://blog.csdn.net/weixin_44162361/article/details/119044059

### 树转换为二叉树

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311021742266.png)

1. 加线，在所有兄弟节点之间加一条连线
2. 去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除他与其他孩子结点间的连线
3. 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。如右图所示。

### 森林转换为二叉树

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/bz1.png)

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/bz2.png)

1. 把森林中的每颗树转换为二叉树
2. 第―棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。如右图所示。

### 二叉树转换为树

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202312061651091.png)

1. 加线：若某节点的左孩子的右孩子结点存在，则将这个左孩子的 n 个右孩子结点都作为此结点的孩子。将这些结点与这些有孩子结点用线连接起来
2. 去线：删除原二叉树中所有结点与其右孩子结点的连线
3. 层次调整

### 二叉树转换为森林

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202312061657492.png)

1. 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除(注：是根节点的右孩子 n 个右孩子)
2. 再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。如右图所示。

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202312061657403.png) 3. 将每颗分离后的二叉树转换为树即可。

### 树与森林的遍历

#### 树的遍历

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310301524568.png)

1. 先根遍历：先访问树的根结点，然后依次先序遍历树的每颗子树。ABEFCDG
2. 后根遍历：先依次后序遍历每棵子树，然后再访问根结点。EFBCGDA
   - **树的先根遍历和二叉树的先序遍历结果相同**
   - **树的后根遍历和二叉树的中序遍历结果相同**
3. 口诀：树先先，树后中

#### 森林的遍历

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310301524253.png)

1. 先序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。ABCDEFGHJI。
2. 中序遍历：先访问森林中第一棵树，中遍历的方式遍历每棵子树，然后再访问根结点，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。BCDAFEJHIG。
   - **森林的前序遍历和二叉树的前序遍历结果相同**
   - **森林的中序遍历和二叉树的中序遍历结果相同**
3. 口诀：森先先，森中中

### 哈夫曼树

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/hfm_tree.png)

哈夫曼树又称**最优树**。有一下几个概念
**树的概念**：

1. **路径**：从树中的一个结点到另外一个结点之间的分支构成的这两个结点之间的路径。
2. **路径长度**：路径上的分支数目称作路径长度。
3. **树的路径长度**：从树根到每一个结点的路径长度之和。
4. **权**：赋予某一个实体的一个量，是对实体的某个或某些属性的数值化描述。(其实就是属性值)
5. **结点的带权路径长度**：从该结点到树根之间的路径长度与结点上权的乘积。(权\*结点路径)
6. **树的带权路径长度 WPL**：树中所有叶子结点的带权路径长度之和。
7. 哈夫曼树：假设有 m 个权值(W1,W2,W3...W(m)),可以构造一颗还有 n 个叶子结点的二叉树，每个叶子结点的权为 W(i)，**带权路径长度 WPL 最小的二叉树称做最优二叉树或哈夫曼树**，**哈夫曼树中，权值越大的结点离根结点越近**

**如何构建哈夫曼树**

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

(参考)[http://data.biancheng.net/view/316.html]
(参考):大话数据结构彩色笔 204,205 页

### 哈夫曼编码

1. 如何求哈夫曼编码：
   - 1. 先画出哈夫曼树
   - 2. 对哈夫曼树每个结点的左分支改为 0，右分支改为 1，对树根到叶子所经过的路径用 0 或 1 来编码
2. 性质
   - 1：哈夫曼编码是前缀编码
   - 2：哈夫曼编码是最优前缀编码

### 图(Graph)

1. 定义：**是由顶点的有穷非空集合和顶点之间边的集合组成**，通常表示为：G(V, E)，其中，G 表示一个图，V(Vertex)是图 G 中顶点的集合，E(Edge) 是图 G 中边的集合。其中**V(G)为图 G 顶点集合，V(G)不能为空，即在图结构中不能没有顶点**，**E(G)为图边的集合，E(G)可以为空集**
2. 分类：分为有向图和无向图。
   - **有向图**：边集 E(G)为有向边的集合
   - **无向图**：边集 E(G)为无向边的集合
3. **弧**：**弧**在有向图中，比如从顶点 x 到顶点 y 的一条有向边，因此<x,y>和<y,x>是不同的两条边，用尖括号括起来，x 是有向边的始点，y 是有向边的终点。<x,y>也称作一条弧，x 为弧尾，y 为弧头。
4. **边**：**边**在无向图中，顶点对(x,y)是无序的，称为顶点 x 到顶点 y 的一条边，这条边无特定方向，所以(x,y)和(y,x)是同一条边
5. **弧和边的关系**：边包括弧，弧不包括边，**有向边也称为弧**。如<A,D> A 是弧尾，D 是弧头，注意不能写成<D,A>，**为区别弧和边，无向图的顶点用一堆圆括号括起来**

### 图的基本术语

**注**：下面用 n 表示图中顶点数目，用 e 表示边的数目：

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_g1.png)

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_g3.png)

4. **子图**：假如有两个图 G=(V,E)和 G1=(V1,E1),如果 V1 ∈ V,E1 ∈ E,则称 G1 为 G 的子图。
5. **无向完全图和有向完全图**：对于无向图，如果任意两个顶点之间都存在边，即存在 **n(n-1)/2** 条边，则称为无向完全图。对于有向图，如果任意两个顶点之间都存在方向互为相反的两条边，即有 **n(n-1)**条弧，则称为有向完全图。
6. **稀疏图和稠密图**：有很少条边或弧(如：e < nlog2^n，e 表示图中边（或弧）的数量，n 表示图中顶点的数量)的图称为稀疏图，反之称为稠密图
7. **权和网**：每条边/弧可以用一个实数来表示特定含义，这个实数就是权，而带权的图通常称为网
8. **邻接点**： 对于无向图 G，如果图的边(v，v')∈E，则称顶点 v 和 v 互为邻接点，即 v 和 v'相邻接。边(v, v)依附于顶点 v 和 v,或者说边(v, v')与顶点 v 和 v 相关联。其实就是**一条边上的两个顶点，这两个顶点就叫邻接点**
9. **度**: 顶点 v 的度是指和 v 相关联的边的数目，记为 TD(v)，**类似于树的结点的度**。
   - 度的计算公式：e(边数) = (图中各顶点的度相加)/2
   - **入度**：以顶点 v 为头的弧的数目，记为 ID(v);
   - **出度**：以顶点 v 为尾的弧的数目，记为 OD(v);
   - **出入度范例**：上图 G1 中的顶点 v1 的入度 ID(v1)=1，出度 OD(v1)=2，度 TD(v1)=ID(v1)+OD(v1)=3。
10. **路径和路径长度**：路径就是一个顶点到另外一个顶点的顶点序列，类似于一个数组，数组里面是路径的每一个点。**路径长度是一条路径上经过的边或弧的数目**
11. **回路或环**:第一个顶点和最后一个顶点相同的路径称为回路或环。
12. **简单路径、简单回路或简单环**:序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。
13. **连通、连通图和连通分量**：在无向图 G 中，如果从顶点 v 到顶点 v'有路径(**也就是不管中间隔了几个顶点，能通过顶点或边走到另外一个顶点**)，则称 v 和 v'是**连通**的。如果对于图中任意两个顶点 v、v'，都是连通的，则称 G 是连通图。上图无向图 G2 就是连通图。
    - **连通分量**：指无向图中极大连通子图。上图 G3 是非连通图，但 G3 有 3 个连通分量
14. **强连通图**：在**有向图**中，若任意两个顶点 Vi 和 Vj，满⾜从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有⾄少⼀条通路，则称此有向图为强连通图。
    - **强连通分量**：有向图中的极大强连通子图称作有向图的强连通分量。
15. **连通图的生成树**: 一个极小连通子图,它含有图中全部顶点，但只有足以构成一棵树的 n-1 条边,这样的连通子图称为连通图的生成树。图 6.5 所示为 G3 中最大连通分量的一棵生成树。
16. **有向树和生成森林**:有一个顶点的入度为 0，其余顶点的入度均为 1 的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。图 6.6 所示为其一例。
    ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_direction.png)

17. [更多参考相关概念参考](https://blog.csdn.net/zsy3757486/category_11712783.html)

### 图的基本总结

1. 图按照有无方向分为有向图和无向图。有向图由顶点和弧构成，无向图由顶点和边构成。弧有弧尾和弧头之分。
2. 图按照边或弧的多少分为稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。
3. 图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。
4. 图上的边或弧上带权则称为网。
5. 图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量。
6. 无向图中连通且 n 个顶点 n-1 条边叫生成树。有向图中一顶点入度为 0 其余顶点入度为 1 的叫有向树。一个有向图由若干棵有向树构成生成森林。

### 图的存储结构

1. 邻接矩阵(顺序存储)=> **无向图**：图的邻接矩阵（Adjacency Matrix)存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。适用于**稠密图**
   - 判断点 Vi 到 Vj 是否存在边或弧，只需查找矩阵中 arc[i][j]是否为 1 即可。
   - 判断顶点的度：这个顶点 Vi 在第 i 行的元素之和，
   - 求顶点 Vi 的所有邻接点就是将矩阵隔中的第 i 行元素扫描一遍
     ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_d1.png)
   - **上图详解：**：矩阵里面的每个值，以行算，对应列。都是代表是否存在两个顶点间的边，比如 a[0][2]=1，代表有 横 V0 到 纵向 V2 的边，a[0][0]=0，代表是不存在 V0 到 V0 的边
2. 邻接矩阵(顺序存储)=> **有向图**
   ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/matrix_2.png)
   - Vi 的入度为第 Vi 列各数之和，出度为第 Vi 行各数之和：口诀**行出列入**
3. 邻接矩阵(顺序存储)=> **带权有向图**
   ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311151659128.png)
   - 带权图，两顶点之间如果不直接相连，则用 ∞ 表示
4. - **邻接矩阵优点**：
   1. 便于判断两顶点之间是否有边
   2. 便于计算各个顶点的度。**对于有向图，第 i 行元素之和就是顶点 i 的出度，第 i 列元素之和就是顶点 i 的入度**
5. - **邻接矩阵缺点**：
   1. 不便于增加和删除顶点，
   2. 不便于统计边的数目，时间复杂度为 O(n^2)
   3. 空间复杂度高
6. 邻接表(链式存储)：由**表头节点表和边表组成**，数组与链表相结合，适用于**稀疏图**，类似于**二叉树的兄弟表示法**，**有向图的邻接表按是按图的出度作为链表项**
   ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/graph_link1.png)
   1. 优点：
      - 便于增加和删除顶点
      - 便于统计边的数目，时间复杂度为 O(n+e)
      - 空间效率高
   2. 缺点：
      - 不便于判断顶点之间是否有边。
      - 不便于计算有向图各个顶点的度
   3. 参考：大话数据结构 P224
7. 十字链表(链式存储)：**即邻接表和逆邻接表结合**，
   - 优点：容易求得顶点的出度和入度
8. 邻接多重表(链式存储)：
9.

### 图的遍历

1. 深度优先遍历(Deep First Search)：也称深度优先搜索，沿着某一个深度方向遍历，**借助栈结构来实现(递归)，类似于前序遍历**
   - 当用邻接矩阵表示图时，查找每个顶点的邻接点的时间复杂度为 O(n^2)，其中 n 为图中顶点数。
   - 当以邻接表做图的存储结构时，查找邻接点的时间复杂度为 O(e)，其中 e 为图中边数。
   - 当以邻接表做存储结构时，深度优先搜索遍历图的时间复杂度为 O(n+e)。
2. 广度优先遍历(Breadth First Search): 也称广度优先搜索, 由第一个顶点从上到下顺序遍历，**借助队列结构来实现**
   - 当用邻接矩阵存储时，时间复杂度为 O(n^2);
   - 用邻接表存储时，时间复杂度为 O(n+e)。
3. 共同点：**两者时间复杂度相同，且都不唯一**

[图的遍历例子 1](https://mp.weixin.qq.com/s?__biz=MzI4MDYzNzg4Mw==&mid=2247489326&idx=4&sn=db0b4711d43b40ea493a70a2414da599&chksm=ebb42ffadcc3a6ec884cb8eb2524783a92e8ab06ed3242737a9a719115cd2dd078840e964bbb&scene=27)
[图的遍历例子 2](https://zhuanlan.zhihu.com/p/96139190)

#### 图的遍历例题

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310251549430.png)

如上图所示，已知图 G 的邻接表如图所示若以顶点 B 为出发点，请分别写出深度优先搜索和广度优先搜索的项点序列。

```c
/*
以上图的邻接表为例，链表中为当前顶点的下标，根据邻接表构造分析，

=> 深度优先以栈结构为主，查找当前结点的下一个结点，直到没有下一个结点再从头回溯

1. B的链接点为C(2)，C的链接点为E(4)，E的链接点为F(5)，F的链接点为A(0)，至此A没有连接点，往B的链接点回溯，发现A(0)被遍历过，往C的链接点回溯，发现B(1)被遍历过，往D的链接点回溯，发现C(2)，被遍历过，往E的链接点回溯，D(3)没有被遍历过，所以找到D(3)，遍历完成

所以答案为BCEFAD

2. 根据邻接表画图，看下图，有4种可能，深度遍历有向图时需要根据方向来，没方向按序号或者字母序号来

1. BAFCED, 这个比较特殊，因为走到F就停止了，需要向前回溯，而ED没有被访问也没有被BAF连接，所以只能回溯回C，C连接E，E连接D
2. BCEAFD
3. BCEFAD
4. BCEDAF

=> 广度优先以队列结构为主，可对图进行分层，

以B为结点A作为第2层的第一个结点有
B
AC
FE
D

以C为结点A作为第2层的第一个结点有
B
CA
EF
D

所以广度遍历优先为BACFED或BCAEFD

*/
```

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310251637333.png)

### 最小生成树

1. 定义：**构造连通网的最小代价生成树(也就是路径最小的权值)**，（最小生成树的应用：如城市间造路，要求造价最低）,**最小生成树不唯一，但最小生成树的边的权值之和总是唯一的**
2. 构造最小生成树的算法：
   - 普里姆算法(Prim)：**核心是归并点，时间复杂度 O(n^2)，适用于稠密网**，过程可以看大话数据结构 239 页，严蔚敏数据结构 166 页
   - 普里姆算法(Prim)过程：选择一个起点，选择一条权值最小的边，**如果遇到相同的边，则选择最新添加的顶点的边**，且所选的顶点不能形成环
   - 克鲁斯卡尔算法(Kruskal)：**核心是归并边，时间复杂度 O(elog2e)，适用于稀疏网**，过程可以看大话数据结构 244 页

#### 最小生成树例题

1. 寻找某一个顶点，选择这个顶点权值最小的边，以该点和其连接的点为基础，不断寻找最小值的点
2. 重复上面步骤(边不能围合合并)

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310241749005.png)

如题 图所示为一个地区的交通网，顶点表示城市,边表示连接城市间的公路，边上的权值表示修建公路需花费的造价。现在需要选择能够连通每个城市且总造价最省的 5 条公路请画出修建公路的方案,并给出该工程的总造价。

```c
/*
1. 以B为基准点，最小的边为2，连接B和C
2. C和B的所有边种最小的为6，链接B和G
3. BCG最小的边为7，连接B和D
4. BDGC所有便中最小的边为8，但是不能选8，选择8的话会围合，
5. 排除8之后剩下两个都是10，都不围合，所以连接起来，最小生成树成功

总造价为2+6+7+10+10 = 35
*/
```

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310251531402.jpg)

### 最短路径

1. 定义：是指两顶点之间经过的边上权值之和最少的路径，并且我们称**路径上的第一个顶点是源点，最后一个顶点是终点**。**拓扑排序不唯一**
2. 构造最短路径的算法：
   - 迪杰斯特拉算法(Dijkstra)：
     ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401101822625.png)
   - 弗洛伊德算法(Floyd)：主要目标是求解每一对顶点之间的最短路径

### 最小生成树和最短路径的区别

1. 定义：
   - 最小生成树能够保证整个拓扑图的所有路径之和最小，但不能保证任意两点之间是最短路径。
   - 最短路径是从一点出发，到达目的地的路径最小。
2. 总结：
   - 遇到求所有路径之和最小的问题用最小生成树&并查集解决；
   - 遇到求两点间最短路径问题的用最短路，即从一个城市到另一个城市最短的路径问题。
3. 区别：最小生成树构成后所有的点都被连通，而最短路只要到达目的地走的是最短的路径即可，与所有的点连不连通没有关系。

### 拓扑排序

1. 目的：**解决一个工程是否能顺序进行的问题**，检测是否存在环
2. 有向无环图：一个无环的有向图，简称 DAG 图
3. AOV-网：这种用顶点表示活动,用弧表示活动间的优先关系的有向图称为顶点表示活动的网
4. 拓扑排序：将 AOV-网中所有顶点排成一个线性序列，该序列满足:若在 AOV-网中由顶点 Vi 到顶点 Vj 有一条路径，则在该线性序列中的顶点 Vi 必定在顶点 Vj 之前(**前面走过的，不能再走一次，即不能存在回路**)。

#### 拓扑排序例题：**求拓扑排序序列**

1. 寻找入度为 0 的顶点，删除该顶点和以它为弧尾的弧
2. 不断重复上面的步骤

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310241736883.png)

```c
/*
1. 以上图为例：入度为0的顶点为D，删除D及其弧，序列为[D]
2. 去掉D之后，入度为0的顶点为A，删除A及其弧，序列为[DA]
3. 去掉A之后，入度为0的顶点为E,B，删除这两个之一都可以

4. 以E为例子，删除E，序列为[DAE]，
5. 去掉E后，入度为0的顶点为B，删除B及其弧，序列为[DAEB]
6. 去掉B之后，入度为0的顶点为F，删除F及其弧，序列为[DAEBF], 剩下C，最终为[DAEBFC]

4. 以B为例子，删除B，序列为[DAB]，
5. 去掉B后，入度为0的顶点为E，删除E及其弧，序列为[DABE]
6. 去掉E之后，入度为0的顶点为F，删除F及其弧，序列为[DAEBF], 剩下C，最终为[DABEFC]

所以上面图的拓扑排序序列为[DAEBFC]和[DABEFC]
*/
```

### 关键路径 AOE-网

1. 目的：**找一条从源点到汇点的带权路径长度最长的路径,称为关键路径**
2. AOE-网：即以边表示活动的网。AOE-网是一个带权的有向无环图，其中，顶点表示事件，弧表示活动，权表示活动持续的时间。通常，AOE-网可用来估算工程的完成时间.
3. **源点**：由于整个工程只有一开始点和完成，所以在正常情况下，**网中只有一个入度为 0 的点，称为源点**
4. **汇点**：出度为零的点
5. **关键活动**：关键路径上的活动。
6. **事件**：图的顶点
7. **活动**：图的边

### 查找

1. **查找表**：由同一类型的数据元素构成的集合。比如：线性表，树表，散列表等
2. **关键字**：关键字是数据元素(或记录)中某个数据项的值，用它可以标识一个数据元素(或记录)。若关键字可以唯一地标识一个记录，则称此关键字为**主关键字**，比如某个字段的 id。反之，以识别若干记录的关键字为**次关键字**，比如某张表表的涨跌幅(可重复)。
3. **查找**：查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称**查找成功**;若表中不存在关键字等于给定值的记录，则称**查找不成功**，此时查找的结果可给出一个“空”记录或“空”指针。
4. **动态查找表和静态查找表**：若在查找的同时对表做修改操作(如插入和删除),则相应的表称之为**动态查找表**，否则称之为**静态查找表**。换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功返回;否则插人关键字等于给定值的记录。
5. **平均查找长度**：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度

### 线性表的查找

1. 顺序查找：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功;反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。
   - **哨兵**：当数据元素特别大的时候，每次循环少进行一次越界判断，这样会节省几乎一半的时间。[参考地址](https://blog.csdn.net/KingOfMyHeart/article/details/117135189)
   - 时间复杂度：O(n)
   - 优点：算法简单，对表结构无任何要求，既适用于顺序结构，也使用于链式结构。
   - 缺点：平均查找长度较大，查找效率低，所以 n 很大时不适合采用顺序查找。
   - **顺序查找时,若第一个即为待查找元素,则查找次数为 1,若第二个是待查找元素,则查找次数为 2,所以长度为 n 的顺序表，总查找次数是 1+2+3+...+n=(1+n)\*n/2 次。而每个元素是待查找数的概率是相等的,为 1/n,那么平均查找次数就是总查找次数乘以每个元素是待查找元索的概率,即(n+1)/2 次。**
2. 折半查找：又称**二分查找**，折半查找必须采用顺序存储结构, 时间复杂度为 O(log2^n)
   - **判断折半查找的值时，下标应该从 1 开始，但是写代码的应该从 0 开始**
   - 优点：比较次数少，查找效率高。
   - 缺点：对表结构要求高，只能用于顺序存储的有序表，且不适用于数据元素经常变动线性表。

```c
/*
对(5,16,20,27,30,36,44,55,60,67)写出27数据元素的查找过程
下班从1开始
第一轮，low=1,high=10，mid=(1+10)/2 = 5，即指向编号30,30>27,high=mid-1，此时low=1,high=4,对比值为30
第二轮，low=1,high=4,mid=(1+4)/2=2,即指向编号16，16<27,low= mid+1，此时low=3,high=4,对比值为16
第三轮，low=3,high=4, mid=(3+4)/2=3,指向编号20, 20<27，low= mid+1，此时low=4,high=4，low=high,对比值为20
第四轮，low=4,high=4，mid=(4+4)/2=3，指向27,27=27，,对比值为27找到元素，返回
*/
```

3. 分块查找：又称**索引顺序查找**，性能介于顺序查找和折半查找之间
   ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/block_search.png)
   - 次查找除表本身外，还需建议一个"索引表"，其中包含两项内容：关键字项(其值为该子表内的最大关键字)和指针项(指示该子表的第一个记录在表中位置)，第 n 个子表中所有记录的关键字均大于第 n-1 个表中的最大关键字
   - 查找过程：**先确定待查记录所在的快，然后在块中顺序寻找**
   - 可用方法：**由于由索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是任意排列的,则在块中只能是顺序查找。**
   - **分块查找的最佳块长**: S = n^(1/2)，比如长度 255，最佳块长为 15，长度为 81，最佳块长为 9
   - 优点：由于块内无序，所以插入和删除比较容易，无需大量移动。
   - 缺点：需要额外增加一个索引表的存储空间并对初始索引表进行排序运算。

### 树表的查找------二叉排序树

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/ecpxs.png)

1. 二叉排序树：又称**二叉查找树**，它或是一颗空树，或是具有下列性质的二叉树：
   - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值;
   - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;
   - 它的左、右子树也分别为二叉排序树。
   - 原理：
2. **二叉排序树查找过程**：将给定值 key 与根节点进行比较，大于则递归查找其右子树，小于则递归查找其左子树，相同直接返回根结点地址；
3. **二叉排序树插入过程**：若二叉排序树为空，则待插入节点插入到空树中，如果非空则将结点与根节点进行比较，大于结点插入右子树，小于结点插入左子树
4. **二叉排序树创建过程**：**对某个结点进行二叉塑造，一个数小于该节点则作为该结点的左子树，大于该节点作为该节点的右节点，不断塑造下去(递归)，形成二叉排序树**，接着对**二叉排序树进行中序遍历，就得到了一个顺序表**
5. 优缺点：
   - 优点：插入和删除的时间性能比较好
   - 缺点：查找性能差
6. 时间复杂度：O(log2^n)

### 树表的查找------平衡二叉树(AVL)树

1. 平衡二叉树：平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：
   - **左子树和右子树的深度之差的绝对值不超过 1**
   - 左子树和右子树也是平衡二叉树
2. **平衡因子 BF**：**二叉排序树上结点的左子树和右子树的深度之差**。平衡因子只能是-1,0，1；
3. 最小不平衡树：距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树
4. 平衡二叉树的调整方法：[参考地址](https://www.cnblogs.com/banmei-brandy/p/13608479.html)

   - 找到最小不平衡子树（如果有多个，一般是最下面那个）
   - 从根节点出发，沿插入路径找三个节点。
   - 调整这三个节点。（找出中位数，让中位数作为根节点，其余两个一左一右）
   - 剩下的节点，左右子树的位置保持不变，再找到最后一个节点的插入位置。

5. 优缺点：
   - 优点：弥补了二叉排序树的查找性能，使查找性能更好
   - 缺点：无

#### 平衡二叉树例题

```js
/*
给定表(15，11，8，20，14，13)，试按元素在表中的顺序将它们依次插入一棵初始时为空的二叉排序树，画出插入完成后的二叉排序树，并判断该二叉排序树是否为平衡二叉排序树，若为非平衡二叉排序树，将它调整为平衡二叉排序树。
*/
```

1. 给定表的二叉排序树

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310261639404.png)

2. 对上面的二叉排序树树进行平衡调整后的平衡二叉树

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310271546087.png)

### 树表-多路查找树(B-树前置知识)

1. 定义：其每一个结点的孩子数可以多余两个，且每个结点处可以存储多个元素
2. 2-3 树：每个结点都具有 2 个或 3 个孩子，一个 2 结点包括一个元素和两个孩子，一个 3 结点包括一小一大两个元素和三个孩子

### B 树

1. **B 树的阶**：结点最大的孩子数目称为 B 树的阶
2. 特点：
   - 如果根结点不是叶结点，则其至少有两棵子树。
   - 每一个非根的分支结点都有 k-1 个元素和 k 个孩子，其中[m/2]≤k≤m。每一个叶子结点 n 都有 k-1 个元素，其中[m/ 2≤k≤m。
   - 所有叶子结点都位于同一层次。

### 树表的查找------B-树 => B 杠树

1. B-树：一棵 m 阶的 B-树，或为空树,或为满足下列特性的 m 叉树:
   1. 树中每个结点至多有 m 棵子树;
   2. 若根结点不是叶子结点，则至少有两棵子树;
   3. 除根之外的所有非终端结点至少有 m/2 棵子树;
   4. **所有的叶子结点都出现在同一层次上**，并且不带信息，通常称为失败结点（失败结点并不存在，指向这些结点的指针为空。引入失败结点是为了便于分析 B-树的查找性能);
   5. **所有的非终端结点最多有 m-1 个关键字 **
   6. **树中每个结点中的关键字都是有序**
2. 特点：平衡，有序，多路
3. [参考链接](https://blog.csdn.net/a519640026/article/details/106940115/)

### 树表的查找------B+树

1. B+树是 B-树的变形树，更适合文件索引系统
2. B+树能够更有效地查找单个关键字，而且更适合查找某个范围内的所有关键字。

------------------从 B-树开始看

### 散列表(哈希表 hash table)的查找

1. **散列查找法**：又称**杂凑法，散列法**
2. 术语定义：
   - **散列技术**：在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f (key)。查找时，根据这个确定的对应关系找到给定值
   - **散列函数和散列地址**:在记录的存储位置 p 和其关键字 key 之间建立一个确定的对应关系 H，使 p= H(key)，称这个对应关系 H 为散列函数，p 为散列地址。
   - **散列表**：一个有限连续的地址空间。通常是一个数组，散列地址是数组的下标。即**存储位置=f(关键字)**
   - **冲突和同义词**：对不同的关键字可能得到同一散列地址。即 k1≠k2,而 H(k1)=H(k2)，称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，k1 和 k2 互称为同义词
   - **装填因子**= 表中填入的记录数/散列表的长度
   - 优点：查找效率高
   - 缺点：空间效率低
3. 散列表的构造方法：
   1. **数字分析法**：**事先必须明确知道所有的关键字每一位上各种数字的分布情况**。
   2. 平方取中法：对关键字取平方再抽取中间 3 位。**适合不知道关键字的分布，而位数又不是很多的情况。**
   3. 折叠法：对关键字从左到右分割成位数相等的几部分，然后叠加求和，按散列表表长，取后几位作为散列地址。**适合关键字位数较多的情况**
   4. **除留余数法**：f(key) = key mod p (p<=m)，(mod：取余，相当于%),**因此根据前辈们的经验，若散列表表长为 m，通常 p 为小于或等于表长（最好接近 m）的最小质数或不包含小于 20 质因子的合数。**
      - 质数：质数是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数
      - 合数：合数是指在大于 1 的整数中除了能被 1 和本身整除外，还能被其他数（0 除外）整除的数
4. 散列表处理冲突的方法：
   - **开放地址法**：所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到,并将记录存入。通常把寻找“下一个”空位的过程称为**探测**,
     1. 公式：Hi = (H(key)+di)%m
     2. **堆积/二次聚集**：在处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象
     3. **生成的散列表长度，如果没有特别指定，那么以 mod 为准**
   - **链地址法**：链地址法的基本思想是:把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有 m 个散列地址就有 m 个单链表，同时用数组 HT0…m-1]存放各个链表的头指针，凡是散列地址为 i 的记录都以结点方式插入到以 HT[i]为头结点的单链表中。

#### 开放地址法的详细分类和介绍

1. **线性探测法**：Hi = (H(key)+di)%m (di = 1,2,3,...,m-1)(**m 为表长度**)这将散列表假想成一个循环表，发生冲突时，从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找，直到找到一个空位，就把此元素放入此空位中。如果找不到空位，则说明散列表已满，需要进行溢出处理。
   - **优点**：只要散列表未填满，总能找到一个不发生冲突的地址。
   - **缺点**：会产生二次聚集

```c
/* 具体例子：
设有关键字集合为{12,67,16,25,37,22,29,15,47,,48,34}，表长为12
当计算前5个数时都是没有冲突的散列地址，直接存入，直到key=37时，37%12=1,但是1与25所在位置冲突，所以
就需要应用开放地址法公式：f(37)=(f(37)+1) mod 12 = 2，所以将37存入下标为2的位置。如果f(37)等于2时仍然没有位置，那就需要f(37)=(f(37)+2) mod 12 = 3，不符合就继续递增，当超过表长时就从0开始，再找不到说明满了
*/
```

```c
/*
例题：一组记录关键字(55,76,44,32,64,82,20,16,43)，用散列函数H(key)=key％11将记录
  散列到散列表HT[0..12]中去，用线性探测法解决冲突。
*/
```

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311041550144.png)

2. **二次探测法**：Hi = (H(key)+di)%m，[di = 1^2,-(1^2),2^2, -(2^2),...,k^2,-(k^2)],(k<=m/2)
   - **优点**：能避免产生二次聚集
   - **缺点**：不能保证一定找到不发生冲突的地址。
3. **伪随机探测法**：Hi = (H(key)+di)%m，di=伪随机数序列。优缺点同**二次探测法**一样。

#### 链地址法的介绍

把冲突的都放到链表里面，每个 index 下存储一个链表，链表里面是 index 下所有有冲突地址的集合

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401272354966.png)

```c
/*  具体例子
设有关键字集合为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数H(key) = key % 13，用链地址法处理冲突
0：空
1：-> 14 -> 1 -> 27 -> 79
2：空
3: -> 68 -> 55
4：空
5：空
6：-> 19 -> 84
7：-> 20
8：空
9：空
10：-> 23 -> 10
11：-> 11
13：空
*/
```

### 各查找方法对比

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202310161806475.png)

## 排序

1. **排序：排序是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作。**或将无序序列排成一个有序序列的运算。
2. 内部排序和外部排序：
   - **内部排序**：指的是待排序记录全部存放在计算机内存中进行排序的过程;
   - **外部排序**：指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。
3. 内部排序方法的分类
   - 插入法：插入排序。折半插入排序，希尔排序
   - 交换类：冒泡排序，快速排序
   - 选择类：简单选择排序，树形选择排序和堆排序。
   - 归并类：归并排序
   - 分配类：基数排序
4. 排序算法效率的评价指标：**执行时间(时间复杂度)**，**辅助空间(空间复杂度)**
5. **排序算法的稳定性：即大小相同的两个值在排序之前和排序之后的先后顺序不变，这就是稳定的。**
6. [所有排序参考](https://blog.csdn.net/PoGeN1/article/details/130462042)

## 插入排序

### 直接插入排序

1. 定义：插入排序算法是所有排序方法中最简单的一种算法，其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据。
2. 时间复杂度：O(n^2)
3. 空间复杂度：O(1)，只需要一个记录的辅助空间
4. [直接插入排序参考地址](http://m.biancheng.net/view/3439.html)
5. 核心过程：每次只对第 i 个进行排序，保证从 0 到 i 个是顺序的，不像冒泡，一次性对比全部
6. 算法特点：
   - 稳定排序
   - 算法简便，且容易实现
   - 也适用于链式存储结构，只是在单链表上无需移动记录，只需修改相应的指针。
   - 更适合于初始记录基本有序(正序)的情况，当初始记录无序,n 较大时,此算法时间复杂度较高，不宜采用。
   - **原始数据越接近有序或待排序记录个数较少时，排序速度越快**、
7. 最好最坏情况：
   - 最好：比较 n-1 次，移动 0 次，时间复杂度 O(n)
   - 最坏：O(n^2)

```c
/**
   若一组记录的排序码为(46,79,56,38,40,84)，则利用直接插入排序的从小到大排，求排序的每一轮过程
   -----解答-----------
   后index个，和index前面的比，如果比前面的某个大，就插入到那一个的位置，其他的向后移动
   第一轮：index=1时，46,79,56,38,40,84
   第二轮：index=2时，46,56,79,38,40,84
   第三轮：index=3时，38,46,56,79,40,84
   第四轮：index=4时，38,40,46,56,79,84
   第五轮：index=5时，38,40,46,56,79,84
*/
```

### 折半插入排序

1. 定义：跟直接插入排序一样，只是增加了一个折半查找法判断插入位置
2. 时间复杂度，空间复杂度：和直接插入排序一样
3. 算法特点：

   - 稳定排序
   - 因为要进行折半查找，所以只能用于顺序结构，不能用于链式结构。
   - 适合初始记录无序，n 较大时的情况。
   - **关键字与待排序对象序列的初始排列无关，仅依赖于对象个数，但需要经过(log2^i + 1)次关键字比较**

4. 和直接插入排序对比：
   - 当 n 较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差
   - 在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少;

### 希尔排序

0. 基本思想：**先将整个待排记录序列分割成若干子序列，分别进行直接插入排序待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。**
1. 定义：希尔排序又称**缩小增量排序**，是对直接插入排序的改进
2. 时间复杂度：O(N^1.3)
3. 空间复杂度： O(1)
4. 间隔划分公式：i = m/3+1，不是划分为 i，而是间隔为 i
5. 算法特点:
   - 记录跳跃式地移动导致排序方法是不稳定的。
   - 只能用于顺序结构，不能用于链式结构。
   - 总比较数和移动次数都比直接插入排序少，n 越大时效果越明显。所以适合初始记录无序，n 较大时的情况。
6. [希尔排序参考链接 1](https://baijiahao.baidu.com/s?id=1719645128431014366&wfr=spider&for=pc)
7. [希尔排序参考链接 2](https://blog.csdn.net/qq_43471489/article/details/125573835)

## 交换排序

### 冒泡排序

1. 时间复杂度：O(n^2)
2. 空间复杂度： O(1)
3. 算法特点:
   - 稳定排序
   - 可用于链式结构
   - 移动记录次数较多，算法平均时间性能比直接插入排序差。当初始记录无序,n 较大时，此算法不宜采用。
   - **可以说是效率最低的排序方法**
4. 最好最坏情况：
   - 最好：比较次数 n-1，移动次数 0，时间复杂度 O(n^2)

```c
/**
   若一组记录的排序码为(46,79,56,38,40,84)，则利用冒泡排序的从小到大排，求排序的每一轮过程
   -----解答-----------
   前一个和后一个比，如果前面比后面大就交换位置
   第一轮：46,56,38,40,79,84
   第二轮：46,38,40,56,79,84
   第三轮：38,40,46,56,79,84
*/
```

### 快速排序

1. 定义：**由冒泡排序改进而得**，在冒泡排序过程中，只对相邻的两个记录进行比较,因此每次交换两个相邻记录时只能消除一个逆序。如果能通过两个(不相邻)记录的一次交换，消除多个逆序，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序。
2. 时间复杂度：最好 O(nlog2^n) 最坏 O(n^2)
3. 空间复杂度： 最好情况下 O(log2^n) 最坏 O(n)
4. 算法特点:
   - **左小右大**
   - **不稳定排序**
   - 可用于链式存储结构
   - 移动记录次数较多，算法平均时间性能比直接插入排序差。当初始记录无序，n 较大时此算法不宜采用
   - **不适合对原本有序或基本有序的记录序列进行排序，相当于退化成冒泡排序**
   - **输入次序越乱越好，排序越快**
5. [快速排序参考链接](https://blog.csdn.net/m0_61545891/article/details/122588499)

```c
/**
   若一组记录的排序码为(46,79,56,38,40,84)，则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为
   -----解答-----------
   原则： L的值要大于才能移动，R的值要小于才能移动
   假定下标为46，此时L=1，值46，R=6，值84
   1. 从R开始，R值84>46，继续向左移动到R=5，值40<46，L和R交换位置，此时L值为40，R为46，呈现(40,79,56,38,46,84)
   2. 上面R调换过，接下来从L开始，L+1=2，值为79，79>46，所以L和R调换位置，呈现(40,46,56,38,79,84)
   3. 上面L调换过，接下来从R开始，R-1=4, 值为38，38<46，所以L和R调换位置，呈现(40,38,56,046,79,84)
   4. 上面R调换过，接下来从L开始，L+1=3，值为56，56>46，所以L和R调换位置，呈现(40,38,46,56,79,84)
   5. 上面L调换过，接下来从R开始，R=1=3，左右指针重合，不做计算，第一轮最终值为(40,38,46,56,79,84)
*/
```

## 选择排序

### 简单选择排序/直接选择排序

1. 时间复杂度：O(n^2)
2. 空间复杂度： O(1)
3. 算法特点:

   - 不稳定排序
   - 可用于链式结构
   - 移动次数较少
   - 总体上要略优于冒泡排序
   - **总共需要比较 n-1 趟**
   - **总共需要比较 n(n-1)/2**

4. [简单选择排序参考链接](https://blog.csdn.net/weixin_52811588/article/details/126486829)

```c
/**
   若一组记录的排序码为(46,79,56,38,40,84)，则利用直接插入排序的从小到大排，求排序的每一轮过程
   -----解答-----------
   每次找出剩余index里面的最小值，将最小值与当前index交换位置
   第一轮：index=0时, 38,79,56,46,40,84
   第二轮：index=1时, 38,40,56,46,79,84
   第三轮：index=2时, 38,40,46,56,79,84
*/
```

### 堆排序

1. ​ 堆（heap）：一个完全二叉树，每个节点都比子节点的值大或小
2. 大根堆：每个节点的值都比其子节点大
3. 小根堆：每个节点的值都比其子节点小
4. 算法特点:
   - 是不稳定排序
   - 只能用于顺序结构，不能用于链式结构
   - 堆化的时候耗时比较多，但是堆化后排序会非常快，整个排序过程类似于二分排序
   - **不适合记录个数 n 较小的情况，记录多时相对快速排序，较为高效，适合 n 较大的情况**
5. 复杂度
   - 时间复杂度：O(nlog2^n)
   - 空间复杂度：O(1)
6. [堆排序参考链接](https://blog.csdn.net/Alian_1223/article/details/127841954?spm=1001.2014.3001.5502)
7. [堆排序参考链接](https://blog.csdn.net/weixin_45891612/article/details/128087620)

```c
/**
   如何构造大小根堆？
   1. 找到最后一个非叶子节点，从最后一个非叶子节点开始，从右至左，从下至上进行调整。
   2. 调整规则：找到该节点和他的所有子节点。如果该节点中存的值是找到节点值中的最大值，则不进行调整。如果不是，就将该节点的值和最大值进行交换，然后递归的调整和该节点交换值得的个节点。

   已知一组待排记录的关键字序列为(15，11，17，59，14，35，13，17，24，84)，请给出对应的小根堆序列。

*/
```

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202311101630088.png)

## 归并类

### 归并排序

1. 定义：将两个或两个以上的有序表合并成一个有序表的过程。
2. 时间复杂度：O(nlog2^n)
3. 空间复杂度 O(n)
4. 算法特点:
   - 是稳定排序
   - 可用于链式结构，且不需要附加存储空间，但递归实现时仍需要开辟相应的递归工作栈
   - **仅需 log2^N 趟**
5. [归并排序参考链接](https://blog.csdn.net/qq_43575801/article/details/127560973)

```c
/*
二分归并排序的解法
假设含有n个序列，对n个序列两两归并，得到[n/2]个长度为2或1的有序子序列；再两两归并，不断重复，直至得到一个长度为n的有序序列位置，看下面例题

1. 将一组键值{80,50,65,13,86,35,96,57,39,79,59,15}应用二路归并排序算法，写出各躺的结果
第一趟：[50,80],[13,65],[35,86],[57,96],[39,79],[15,59]
第二趟：[13,50,65,80],[35,57,86,96],[15,39,59,79]
第三趟：[13,35,50,57,65,80,86,96],[15,39,59,79]
第四趟：[13,15,35,39,50,57,59,65,79,80,86,96]
*/
```

## 分配类

### 基数排序

0. 让从小到大的位排序。
1. [基数排序参考链接](https://blog.csdn.net/Alian_1223/article/details/128016434)
2. 算法特点:
   - 是稳定排序
   - 可用于链式结构，也可用于顺序结构
   - 时间复杂度可以达到 O(d·n)
   - 使用条件有严格的要求：需知道各级关键字的主次关系和各级关键字的取值范围

## 各排序方法简介表

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202309221538006.png)

1. 不稳定的算法的记忆法：**快速选择堆希尔**

## 结论

1. 当待排序的记录个数 n 较小时，n 和 nloga2^n 的差别不大，可选用简单的排序方法。而当关键字基本有序时，可选用直接插入排序或冒泡排序，排序速度很快，其中**直接插入排序最为简单常用，性能最佳**。
2. 当 n 较大时，**快速排序**最佳
3. 不能用于链式结构的：堆排序，希尔排序
4. 性能最好的：快速排序，归并排序，堆排序，希尔次之
5. 随机，不追求稳定性用快排。有序，不稳定用堆。有序，稳定用归并
6. 基数适合 n 值很大而关键字较小的序列
7. 待排记录有序时，使用直接插入排序和冒泡排序最好，有时能达到 O(n)，但这最不适合快速排序，这时快排会退化到 O(n^2)
8. 简单选择排序，堆排序和归并排序的时间性能不随记录序列中关键字的分布而变化

### 最小生成树注意点

1. 带权的图，画最小生成树要把所有权值标出来
2. 写出遍历序列时，可以不用加括号，参考下面**例题 1**

#### 最小生成树例题 1

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401111953692.png)

- (1)深度优先遍历序列为:1,2,3,6,4,5
- (2)普里姆算法
  ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401111956862.png)

### 构造哈夫曼树注意点

1. 如果两个最小的点一致，那么也要选这两个点在一起合并成一个新结点

### 构造哈夫曼树例题 1

1. 若以(4,5,6,7,8)作为权值构造哈夫曼树，画图,并求其带权路径长度 WPL,和每个点的哈夫曼编码
   ![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202401270045314.png)

### 画广义表

![](https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202402062149801.png)
